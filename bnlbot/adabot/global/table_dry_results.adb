
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- c:/bnl/svn/wcs-std/sattmate/script/local/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with   Text_Io ;
with Ada.Strings.Fixed;

package body Table_Dry_results is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  -- Primary key, if several fields
  Stm_Select_I1_Market_id_O,
  Stm_Select_I1_Market_id,
  Stm_Delete_I1_Market_id : Sql.Statement_Type; 


  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_Dry_results.Data_Type is
    Data : Table_Dry_results.Data_Type;
  begin
    if not Sql.Is_Null(Stm, "MARKET_ID") then
      Sql.Get(Stm, "MARKET_ID", Data.Market_id);
    else
      Data.Market_id := 0;
    end if;
    if not Sql.Is_Null(Stm, "SELECTION_ID") then
      Sql.Get(Stm, "SELECTION_ID", Data.Selection_id);
    else
      Data.Selection_id := 0;
    end if;
  return Data;
  end Get;
---------------------------------------------

  function Get(Market_id : Integer_4;
                       Selection_id : Integer_4) return Table_Dry_results.Data_Type is
    Data       : Table_Dry_results.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Market_id := Market_id;
    Data.Selection_id := Selection_id;
    Read(Data, End_Of_Set);
    return Data;
  end Get;
--------------------------------------------

  procedure Read_All(List  : in out Dry_results_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_All_O, "select * from DRY_RESULTS order by MARKET_ID, SELECTION_ID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Sql.Prepare(Stm_Select_All, "select * from DRY_RESULTS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_All;
--------------------------------------------


  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out Dry_results_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Count       : Integer_4 := 0;
    Data        : Table_Dry_results.Data_Type;
    Eos         : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Open_Cursor(Stm);
    loop
      Sql.Fetch(Stm, Eos); 
      exit when Eos or Count > Max;
      Data := Get(Stm);
      Dry_results_List_Pack.Insert_At_Tail(List, Data);
      Count := Count +1;
    end loop;
    Sql.Close_Cursor(Stm);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_List;
--------------------------------------------

  function Is_Existing(Market_id : Integer_4;
                       Selection_id : Integer_4) return Boolean is
    Data       : Table_Dry_results.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Market_id := Market_id;
    Data.Selection_id := Selection_id;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;
--------------------------------------------

  procedure Read(Data       : in out Table_Dry_results.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select, " select * from DRY_RESULTS " & 
            "where MARKET_ID=:MARKET_ID" &
            " and SELECTION_ID=:SELECTION_ID" ) ;
    Sql.Set(Stm_Select, "MARKET_ID", Data.Market_id);
    Sql.Set(Stm_Select, "SELECTION_ID", Data.Selection_id);

    Sql.Open_Cursor(Stm_Select);
    Sql.Fetch(Stm_Select, End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Sql.Close_Cursor(Stm_Select);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read;
---------------------------------------------

  procedure Delete(Data : in Table_Dry_results.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete, " delete from DRY_RESULTS " & 
            "where MARKET_ID=:MARKET_ID" &
            " and SELECTION_ID=:SELECTION_ID" ) ;
    Sql.Set(Stm_Delete, "MARKET_ID", Data.Market_id);
    Sql.Set(Stm_Delete, "SELECTION_ID", Data.Selection_id);

    Sql.Execute(Stm_Delete);
  end Delete;
--------------------------------------------

  procedure Insert(Data : in out Table_Dry_results.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
  begin
    if not Keep_Timestamp then
      null; --for tables without IXX*
    end if;
    Sql.Prepare(Stm_Insert, "insert into DRY_RESULTS values (" &
            ":MARKET_ID, " &
            ":SELECTION_ID) " ) ;
    Sql.Set(Stm_Insert, "MARKET_ID",Data.Market_id);
    Sql.Set(Stm_Insert, "SELECTION_ID",Data.Selection_id);

    Sql.Execute(Stm_Insert);
  end Insert;
--------------------------------------------

  -- Primary key, when several fields

  procedure Read_I1_Market_id(Data  : in     Table_Dry_results.Data_Type;
                       List  : in out Dry_results_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if (Start_Trans) then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_I1_Market_id_O, " select * from DRY_RESULTS " & 
            "where MARKET_ID=:MARKET_ID" &
            " order by MARKET_ID, SELECTION_ID"); 
      Sql.Set(Stm_Select_I1_Market_id_O, "MARKET_ID", Data.Market_id);
 
      Read_List(Stm_Select_I1_Market_id_O, List, Max);
    else
      Sql.Prepare(Stm_Select_I1_Market_id, " select * from DRY_RESULTS " & 
            "where MARKET_ID=:MARKET_ID" ) ; 
      Sql.Set(Stm_Select_I1_Market_id, "MARKET_ID", Data.Market_id);
 
      Read_List(Stm_Select_I1_Market_id, List, Max);
    end if;
    if (Start_Trans) then Sql.Commit(Transaction); end if;
  end Read_I1_Market_id;
  --------------------------------------------

  procedure Delete_I1_Market_id(Data  : in     Table_Dry_results.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_I1_Market_id, " delete from DRY_RESULTS " & 
            "where MARKET_ID=:MARKET_ID" ) ; 
      Sql.Set(Stm_Delete_I1_Market_id, "MARKET_ID", Data.Market_id);
 
    Sql.Execute(Stm_Delete_I1_Market_id);
  end Delete_I1_Market_id;
  --------------------------------------------


  
  -- Procedures for all DBMS


--------------------------------------------



  function To_String(Data : in Table_Dry_results.Data_Type) return String is
  begin
    return
          " Market_id = " & Integer_4'Image(Data.Market_id) &
          " Selection_id = " & Integer_4'Image(Data.Selection_id) &
          "";
  end To_String;
--------------------------------------------

 
--------------------------------------------


end Table_Dry_results ;

