-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- c:/bnl/svn/wcs-std/sattmate/script/local/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------



pragma Warnings(Off);
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Sattmate_Types, Sattmate_Calendar, Uniface_Request, Sql, Simple_List_Class;

package Table_Dry_runners is

  use Sattmate_Types, Sattmate_Calendar, Uniface_Request;

  type Data_Type is record
      Market_id :    Integer_4  := 0 ; -- Primary Key
      Selection_id :    Integer_4  := 0 ; -- Primary Key
      Index :    Integer_4  := 0 ; --
      Back_price :    Float_8  := 0.0 ; --
      Lay_price :    Float_8  := 0.0 ; --
      Runner_name :    String (1..0) := (others => ' ') ; --
  end record;
  Empty_Data : Table_Dry_runners.Data_Type;
  -- 
  -- Table name as string 
  --
  Table_Dry_runners_Name : constant String := "DRY_RUNNERS";
  Table_Dry_runners_Set_Name : constant String := "DRY_RUNNERS_SET";
  Table_Dry_runners_Row_Name : constant String := "DRY_RUNNERS_ROW";
  -- 
  -- Column names as strings 
  --
  Market_id_Name : constant String := "MARKET_ID";
  Selection_id_Name : constant String := "SELECTION_ID";
  Index_Name : constant String := "INDEX";
  Back_price_Name : constant String := "BACK_PRICE";
  Lay_price_Name : constant String := "LAY_PRICE";
  Runner_name_Name : constant String := "RUNNER_NAME";
  -- 
  -- Column names as enumerator literals 
  --
  type Column_Type is (
        Market_id,
        Selection_id,
        Index,
        Back_price,
        Lay_price,
        Runner_name);

  package Dry_runners_List_Pack is new Simple_List_Class(Table_Dry_runners.Data_Type);

  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_Dry_runners.Data_Type;
  --------------------------------------------
  procedure Read(Data       : in out Table_Dry_runners.Data_Type;
                 End_Of_Set : in out Boolean);
  --------------------------------------------
  function Is_Existing(Market_id : Integer_4;
                       Selection_id : Integer_4) return Boolean;
  --------------------------------------------
  function Get(Market_id : Integer_4;
                       Selection_id : Integer_4) return Table_Dry_runners.Data_Type;
  --------------------------------------------

  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out Dry_runners_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last);
  --------------------------------------------
  procedure Read_All(List  : in out Dry_runners_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last);
  --------------------------------------------
  procedure Delete(Data : in Table_Dry_runners.Data_Type);
  --------------------------------------------
  procedure Update(Data : in out Table_Dry_runners.Data_Type; Keep_Timestamp : in Boolean := False);
  --------------------------------------------
  procedure Insert(Data : in out Table_Dry_runners.Data_Type; Keep_Timestamp : in Boolean := False);
  --------------------------------------------
  -- Primary keys, when several fields

  procedure Read_I1_Market_id(Data  : in     Table_Dry_runners.Data_Type;
                       List  : in out Dry_runners_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last);
  --------------------------------------------

  procedure Delete_I1_Market_id(Data  : in     Table_Dry_runners.Data_Type);
  --------------------------------------------

  function Is_Existing_I1(
                 Market     : in Ada_Type - Found no matching type ;
                 id     : in Ada_Type - Found no matching type )      return Boolean;


  -- Procedures for DBMS UD4

  --------------------------------------------
  procedure Get_Values(Request : in     Request_Type;
                       Data    : in out Table_Dry_runners.Data_Type);
  --------------------------------------------

  procedure Set_Values(Reply  : in out Request_Type;
                       Data   : in     Table_Dry_runners.Data_Type);
  --------------------------------------------

  procedure Make_Ud4_Telegram(Request   : in out Uniface_Request.Request_Type;
                              Operation	: in     Operation_Type := Get_One_Record);
  --------------------------------------------

  procedure Make_Ud4_Telegram(Request   : in out Uniface_Request.Request_Type;
                              Data      : in     Table_Dry_runners.Data_Type;
                              Operation	: in     Operation_Type := Get_One_Record);
  --------------------------------------------




  -- Procedures for all DBMS

  function To_String(Data : in Table_Dry_runners.Data_Type) return String;

  function To_Xml(Data      : in Table_Dry_runners.Data_Type;
                  Ret_Start : in Boolean;
                  Ret_Data  : in Boolean;
                  Ret_End   : in Boolean) return String;

  procedure From_Xml(Xml_Filename : in Unbounded_String;
                     A_List       : in out Dry_runners_List_Pack.List_Type);

end Table_Dry_runners ;

-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- c:/bnl/svn/wcs-std/sattmate/script/local/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_Io, General_Routines, Text_Io, Standard8, Cgi;
with Ada.Strings.Fixed;
with Sax.Readers;              use Sax.Readers;
with Input_Sources.File;       use Input_Sources.File;
with Unicode.CES;
with Unicode.Encodings;
with Sax.Attributes;

package body Table_Dry_runners is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  -- Primary key, if several fields
  Stm_Select_I1_Market_id_O,
  Stm_Select_I1_Market_id,
  Stm_Delete_I1_Market_id : Sql.Statement_Type; 


  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_Dry_runners.Data_Type is
    Data : Table_Dry_runners.Data_Type;
  begin
    if not Sql.Is_Null(Stm, "MARKET_ID") then
      Sql.Get(Stm, "MARKET_ID", Data.Market_id);
    else
      Data.Market_id := 0;
    end if;
    if not Sql.Is_Null(Stm, "SELECTION_ID") then
      Sql.Get(Stm, "SELECTION_ID", Data.Selection_id);
    else
      Data.Selection_id := 0;
    end if;
    if not Sql.Is_Null(Stm, "INDEX") then
      Sql.Get(Stm, "INDEX", Data.Index);
    else
      Data.Index := 0;
    end if;
    if not Sql.Is_Null(Stm, "BACK_PRICE") then
      Sql.Get(Stm, "BACK_PRICE", Data.Back_price);
    else
      Data.Back_price := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "LAY_PRICE") then
      Sql.Get(Stm, "LAY_PRICE", Data.Lay_price);
    else
      Data.Lay_price := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "RUNNER_NAME") then
      Sql.Get(Stm, "RUNNER_NAME", Data.Runner_name);
    else
      Data.Runner_name := (others => ' ');
    end if;
  return Data;
  end Get;
---------------------------------------------

  function Get(Market_id : Integer_4;
                       Selection_id : Integer_4) return Table_Dry_runners.Data_Type is
    Data       : Table_Dry_runners.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Market_id := Market_id;
    Data.Selection_id := Selection_id;
    Read(Data, End_Of_Set);
    return Data;
  end Get;
--------------------------------------------

  procedure Read_All(List  : in out Dry_runners_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_All_O, "select * from DRY_RUNNERS order by MARKET_ID, SELECTION_ID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Sql.Prepare(Stm_Select_All, "select * from DRY_RUNNERS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_All;
--------------------------------------------


  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out Dry_runners_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Count       : Integer_4 := 0;
    Data        : Table_Dry_runners.Data_Type;
    Eos         : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Open_Cursor(Stm);
    loop
      Sql.Fetch(Stm, Eos); 
      exit when Eos or Count > Max;
      Data := Get(Stm);
      Dry_runners_List_Pack.Insert_At_Tail(List, Data);
      Count := Count +1;
    end loop;
    Sql.Close_Cursor(Stm);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_List;
--------------------------------------------

  function Is_Existing(Market_id : Integer_4;
                       Selection_id : Integer_4) return Boolean is
    Data       : Table_Dry_runners.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Market_id := Market_id;
    Data.Selection_id := Selection_id;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;
--------------------------------------------

  procedure Read(Data       : in out Table_Dry_runners.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select, " select * from DRY_RUNNERS " & 
            "where MARKET_ID=:MARKET_ID" &
            " and SELECTION_ID=:SELECTION_ID" ) ;
    Sql.Set(Stm_Select, "MARKET_ID", Data.Market_id);
    Sql.Set(Stm_Select, "SELECTION_ID", Data.Selection_id);

    Sql.Open_Cursor(Stm_Select);
    Sql.Fetch(Stm_Select, End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Sql.Close_Cursor(Stm_Select);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read;
---------------------------------------------

  procedure Delete(Data : in Table_Dry_runners.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete, " delete from DRY_RUNNERS " & 
            "where MARKET_ID=:MARKET_ID" &
            " and SELECTION_ID=:SELECTION_ID" ) ;
    Sql.Set(Stm_Delete, "MARKET_ID", Data.Market_id);
    Sql.Set(Stm_Delete, "SELECTION_ID", Data.Selection_id);

    Sql.Execute(Stm_Delete);
  end Delete;
--------------------------------------------

  procedure Update(Data : in out Table_Dry_runners.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Sql.Prepare(Stm_Update, "update DRY_RUNNERS set " &
            "INDEX=:INDEX," &
            "BACK_PRICE=:BACK_PRICE," &
            "LAY_PRICE=:LAY_PRICE," &
            "RUNNER_NAME=:RUNNER_NAME " &
            "where MARKET_ID=:MARKET_ID " &
            "and SELECTION_ID=:SELECTION_ID " ) ;
    Sql.Set(Stm_Update, "MARKET_ID",Data.Market_id);
    Sql.Set(Stm_Update, "SELECTION_ID",Data.Selection_id);
    if Data.Index = 0 then
      Sql.Set_Null(Stm_Update, "INDEX");
    else
      Sql.Set(Stm_Update, "INDEX",Data.Index);
    end if;
    Sql.Set(Stm_Update, "BACK_PRICE",Data.Back_price);
    Sql.Set(Stm_Update, "LAY_PRICE",Data.Lay_price);
    Sql.Set(Stm_Update, "RUNNER_NAME",Data.Runner_name);

    Sql.Execute(Stm_Update);
  end Update;
--------------------------------------------

  procedure Insert(Data : in out Table_Dry_runners.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      null; --for tables without IXX*
    end if;
    Sql.Prepare(Stm_Insert, "insert into DRY_RUNNERS values (" &
            ":MARKET_ID, " &
            ":SELECTION_ID, " &
            ":INDEX, " &
            ":BACK_PRICE, " &
            ":LAY_PRICE, " &
            ":RUNNER_NAME) " ) ;
    Sql.Set(Stm_Insert, "MARKET_ID",Data.Market_id);
    Sql.Set(Stm_Insert, "SELECTION_ID",Data.Selection_id);
    if Data.Index = 0 then
      Sql.Set_Null(Stm_Insert, "INDEX");
    else
      Sql.Set(Stm_Insert, "INDEX",Data.Index);
    end if;
    Sql.Set(Stm_Insert, "BACK_PRICE",Data.Back_price);
    Sql.Set(Stm_Insert, "LAY_PRICE",Data.Lay_price);
    Sql.Set(Stm_Insert, "RUNNER_NAME",Data.Runner_name);

    Sql.Execute(Stm_Insert);
  end Insert;
--------------------------------------------

  -- Primary key, when several fields

  procedure Read_I1_Market_id(Data  : in     Table_Dry_runners.Data_Type;
                       List  : in out Dry_runners_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if (Start_Trans) then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_I1_Market_id_O, " select * from DRY_RUNNERS " & 
            "where MARKET_ID=:MARKET_ID" &
            " order by MARKET_ID, SELECTION_ID"); 
      Sql.Set(Stm_Select_I1_Market_id_O, "MARKET_ID", Data.Market_id);
 
      Read_List(Stm_Select_I1_Market_id_O, List, Max);
    else
      Sql.Prepare(Stm_Select_I1_Market_id, " select * from DRY_RUNNERS " & 
            "where MARKET_ID=:MARKET_ID" ) ; 
      Sql.Set(Stm_Select_I1_Market_id, "MARKET_ID", Data.Market_id);
 
      Read_List(Stm_Select_I1_Market_id, List, Max);
    end if;
    if (Start_Trans) then Sql.Commit(Transaction); end if;
  end Read_I1_Market_id;
  --------------------------------------------

  procedure Delete_I1_Market_id(Data  : in     Table_Dry_runners.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_I1_Market_id, " delete from DRY_RUNNERS " & 
            "where MARKET_ID=:MARKET_ID" ) ; 
      Sql.Set(Stm_Delete_I1_Market_id, "MARKET_ID", Data.Market_id);
 
    Sql.Execute(Stm_Delete_I1_Market_id);
  end Delete_I1_Market_id;
  --------------------------------------------

  function Is_Existing_I1(
                 Market     : in Ada_Type - Found no matching type ;
                 id     : in Ada_Type - Found no matching type )     return Boolean is
    Data       : Table_Dry_runners.Data_Type;
    End_Of_Set : Boolean := False;
    Is_Exist   : Boolean := False;
    List       : Dry_runners_List_Pack.List_Type := Dry_runners_List_Pack.Create;
  begin
    Data.Market := Market ; 
    Data.id := id ; 
    Read_I1_Market_id(Data, List, False, 1);
    Is_Exist := not Dry_runners_List_Pack.Is_Empty(List);
    Dry_runners_List_Pack.Release(List);
    return Is_Exist;
  end Is_Existing_I1 ;
  --------------------------------------------


  procedure Get_Values(Request : in     Request_Type;
                       Data    : in out Table_Dry_runners.Data_Type) is
  begin
    if Has_Value(Request, "MARKET_ID") then
      Get_Value(Request, "MARKET_ID", Data.Market_id);
    end if;
    if Has_Value(Request, "SELECTION_ID") then
      Get_Value(Request, "SELECTION_ID", Data.Selection_id);
    end if;
    if Has_Value(Request, "INDEX") then
      Get_Value(Request, "INDEX", Data.Index);
    end if;
    if Has_Value(Request, "BACK_PRICE") then
      Get_Value(Request, "BACK_PRICE", Data.Back_price);
    end if;
    if Has_Value(Request, "LAY_PRICE") then
      Get_Value(Request, "LAY_PRICE", Data.Lay_price);
    end if;
    if Has_Value(Request, "RUNNER_NAME") then
      Get_Value(Request, "RUNNER_NAME", Data.Runner_name);
    end if;
  end Get_Values;
--------------------------------------------


  procedure Set_Values(Reply  : in out Request_Type;
                       Data   : in     Table_Dry_runners.Data_Type) is
  begin
    Set_Value(Reply, "MARKET_ID", Data.Market_id);
    Set_Value(Reply, "SELECTION_ID", Data.Selection_id);
    Set_Value(Reply, "INDEX", Data.Index);
    Set_Value(Reply, "BACK_PRICE", Data.Back_price);
    Set_Value(Reply, "LAY_PRICE", Data.Lay_price);
    Set_Value(Reply, "RUNNER_NAME", Data.Runner_name);
  end Set_Values;
--------------------------------------------


  procedure Make_Ud4_Telegram(Request   : in out Uniface_Request.Request_Type;
                              Operation	: in     Operation_Type := Get_One_Record) is
    use Uniface_Request;
    Next_Column : Integer_2;
    Offset      : Natural := 0;
  begin
    Construct_Ud4_Record(Request, "DRY_RUNNERS", 6, Next_Column, Offset, Operation);
    Add_Column(Request, "MARKET_ID", INTEGER_4_FORMAT, Offset);
    Add_Column(Request, "SELECTION_ID", INTEGER_4_FORMAT, Offset);
    Add_Column(Request, "INDEX", INTEGER_4_FORMAT, Offset);
    Add_Column(Request, "BACK_PRICE", FLOAT_8_FORMAT, Offset);
    Add_Column(Request, "LAY_PRICE", FLOAT_8_FORMAT, Offset);
    Add_Column(Request, "RUNNER_NAME", STRING_FORMAT, Offset, 0);
    Init_Values(Request,Offset);
  end Make_Ud4_Telegram;
--------------------------------------------


  procedure Make_Ud4_Telegram(Request   : in out Uniface_Request.Request_Type;
                              Data      : in     Table_Dry_runners.Data_Type;
                              Operation	: in     Operation_Type := Get_One_Record) is
  begin
    Make_Ud4_Telegram(Request, Operation);
    Set_Values(Request, Data);
  end Make_Ud4_Telegram;
--------------------------------------------





  -- Procedures for all DBMS


  function Date_To_String(Date : in Sattmate_Calendar.Time_Type) return String is
    package Integer_2_Io is new Text_Io.Integer_Io(Integer_2);
    Date_String : String(1..10) := "yyyy-mm-dd";
  begin
    Integer_2_Io.Put(Date_String(9..10), Date.Day);
    Integer_2_Io.Put(Date_String(6..7), Date.Month);
    Integer_2_Io.Put(Date_String(1..4), Date.Year);
    if Date_String(9) = ' ' then Date_String(9) := '0'; end if;
    if Date_String(6) = ' ' then Date_String(6) := '0'; end if;
    return Date_String;
  end Date_To_String;
--------------------------------------------



  function To_String(Data : in Table_Dry_runners.Data_Type) return String is
  begin
    return
          " Market_id = " & Integer_4'Image(Data.Market_id) &
          " Selection_id = " & Integer_4'Image(Data.Selection_id) &
          " Index = " & Integer_4'Image(Data.Index) &
          " Back_price = " &  General_Routines.F8_To_String(Data.Back_price) &
          " Lay_price = " &  General_Routines.F8_To_String(Data.Lay_price) &
          " Runner_name = " & General_Routines.Skip_Trailing_Blanks(Data.Runner_name) &
          "";
  end To_String;
--------------------------------------------

  function Format_String(S : in String) return String is
    use Standard8; use CGI;
  begin
     return General_Routines.Skip_Trailing_Blanks(To_String(Cgi.Cvtput_Xml(To_String8(S))));
  end Format_String;
--------------------------------------------

  function To_Xml(Data      : in Table_Dry_runners.Data_Type;
                  Ret_Start : in Boolean;
                  Ret_Data  : in Boolean;
                  Ret_End   : in Boolean) return String is
    Ls      : constant String := "";
    S_Start : constant String := "<DRY_RUNNERS_ROW>"  & Ls;
    S_End   : constant String := "</DRY_RUNNERS_ROW>" & Ls;
    S1 : constant String :=
          "<MARKET_ID>" &  General_Routines.Trim(Integer_4'Image(Data.Market_id)) & "</MARKET_ID>" & Ls;
    S2 : constant String :=
          "<SELECTION_ID>" &  General_Routines.Trim(Integer_4'Image(Data.Selection_id)) & "</SELECTION_ID>" & Ls;
    S3 : constant String :=
          "<INDEX>" &  General_Routines.Trim(Integer_4'Image(Data.Index)) & "</INDEX>" & Ls;
    S4 : constant String :=
          "<BACK_PRICE>" &  General_Routines.F8_To_String(Data.Back_price) & "</BACK_PRICE>" & Ls;
    S5 : constant String :=
          "<LAY_PRICE>" &  General_Routines.F8_To_String(Data.Lay_price) & "</LAY_PRICE>" & Ls;
    S6 : constant String :=
          "<RUNNER_NAME>" & Format_String(General_Routines.Skip_Trailing_Blanks(Data.Runner_name)) & "</RUNNER_NAME>" & Ls;
    --------------------------------
    function Get_String(S : in String; Ret : in Boolean) return String is
      use Standard8;
    begin
      if Ret then return S; else return ""; end if;
    end Get_String;
    --------------------------------
  begin
    return Get_String(S_Start, Ret_Start) & 
           Get_String(
            S1 &  S2 &  S3 &  S4 &  S5 &  S6 ,
            Ret_Data) &
           Get_String(S_End, Ret_End) & Ascii.LF;
  end To_Xml;
  --------------------------------------------


  --------------------------------------------
  type Dry_runners_Reader is new Sax.Readers.Reader with record
    Current_Tag    : Unbounded_String := Null_Unbounded_String;
    Accumulated    : Unbounded_String := Null_Unbounded_String;
    OK             : Boolean := True;
    Found_Set      : Boolean := True;
    Dry_runners_List     : Table_Dry_runners.Dry_runners_List_Pack.List_Type;
    Dry_runners_Data     : Table_Dry_runners.Data_Type := Empty_Data;
  end record;

  overriding procedure Start_Element(Handler       : in out Dry_runners_Reader;
                                     Namespace_URI : Unicode.CES.Byte_Sequence := "";
                                     Local_Name    : Unicode.CES.Byte_Sequence := "";
                                     Qname         : Unicode.CES.Byte_Sequence := "";
                                     Atts          : Sax.Attributes.Attributes'Class);

  overriding procedure End_Element(Handler         : in out Dry_runners_Reader;
                                   Namespace_URI   : Unicode.CES.Byte_Sequence := "";
                                   Local_Name      : Unicode.CES.Byte_Sequence := "";
                                   Qname           : Unicode.CES.Byte_Sequence := "") ;

  overriding procedure Characters(Handler          : in out Dry_runners_Reader;
                                  Ch               : Unicode.CES.Byte_Sequence := "");

  --------------------------------------------
  procedure Start_Element(Handler       : in out Dry_runners_Reader;
                          Namespace_URI : Unicode.CES.Byte_Sequence := "";
                          Local_Name    : Unicode.CES.Byte_Sequence := "";
                          Qname         : Unicode.CES.Byte_Sequence := "";
                          Atts          : Sax.Attributes.Attributes'Class) is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    pragma Warnings(Off,Atts);
    The_Tag : constant String := Local_Name;
  begin
    Handler.Current_Tag := To_Unbounded_String(The_Tag);
    Handler.Accumulated := Null_Unbounded_String;
    if The_Tag = Table_Dry_runners_Set_Name then
      Handler.Found_Set := true;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
    when Constraint_Error         => Handler.OK := False;
  end Start_Element;
  --------------------------------------------

  --------------------------------------------
  procedure End_Element(Handler       : in out Dry_runners_Reader;
                        Namespace_URI : Unicode.CES.Byte_Sequence := "";
                        Local_Name    : Unicode.CES.Byte_Sequence := "";
                        Qname         : Unicode.CES.Byte_Sequence := "") is
    pragma Warnings(Off,Namespace_URI);
    pragma Warnings(Off,Qname);
    The_Tag : constant String := Local_Name;
  begin
    if The_Tag = Table_Dry_runners_Set_Name then
      Handler.Found_Set := false;
    elsif The_Tag = Table_Dry_runners_Row_Name then
      if Handler.Found_Set then
        Table_Dry_runners.Dry_runners_List_Pack.Insert_At_Tail(Handler.Dry_runners_List, Handler.Dry_runners_Data);
        Handler.Dry_runners_Data := Empty_Data;
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end End_Element;
  --------------------------------------------

  --------------------------------------------
  procedure Characters(Handler          : in out Dry_runners_Reader;
                       Ch               : Unicode.CES.Byte_Sequence := "") is
    function To_Iso_Latin_15(Str : Unicode.CES.Byte_Sequence) return String is
      use Unicode.Encodings;
    begin
      return  Convert(Str, Get_By_Name("utf-8"),Get_By_Name("iso-8859-15"));
    end To_Iso_Latin_15;
    The_Tag   : constant String := To_String(Handler.Current_Tag);
    The_Value : constant string := To_Iso_Latin_15(Ch);
    procedure Fix_String (Value    : string;
                          Variable : in out string) is
    begin
      Append(Handler.Accumulated, The_Value);
      Ada.Strings.Fixed.Move(To_String(Handler.Accumulated), Variable);
    end Fix_String;
  begin
    if Handler.Found_Set then
      if    The_Tag = MARKET_ID_Name then 
        Handler.Dry_runners_Data.Market_id := Integer_4'value(The_Value);
      elsif The_Tag = SELECTION_ID_Name then 
        Handler.Dry_runners_Data.Selection_id := Integer_4'value(The_Value);
      elsif The_Tag = INDEX_Name then 
        Handler.Dry_runners_Data.Index := Integer_4'value(The_Value);
      elsif The_Tag = BACK_PRICE_Name then 
        Handler.Dry_runners_Data.Back_price := Float_8'value(The_Value);
      elsif The_Tag = LAY_PRICE_Name then 
        Handler.Dry_runners_Data.Lay_price := Float_8'value(The_Value);
      elsif The_Tag = RUNNER_NAME_Name then 
        Fix_String(The_Value, Handler.Dry_runners_Data.Runner_name);
      end if;
    end if;
  exception
    when Ada.Strings.Length_Error => Handler.OK := False;
  end Characters;

  --------------------------------------------
  procedure From_Xml(Xml_Filename : in Unbounded_String;
                     A_List       : in out Dry_runners_List_Pack.List_Type) is
    My_Reader   : Dry_runners_Reader;
    Input       : File_Input;
  begin
    My_Reader.Dry_runners_List := A_List;
    My_Reader.Current_Tag := Null_Unbounded_String;
    Open(To_String(Xml_Filename), Input);
    My_Reader.Set_Feature(Validation_Feature,False);
    My_Reader.Parse(Input);
    Input.Close;
    if not My_Reader.OK then
       Table_Dry_runners.Dry_runners_List_Pack.Remove_All(My_Reader.Dry_runners_List);
    end if;
    A_List := My_Reader.Dry_runners_List;
  end From_Xml;

end Table_Dry_runners ;

