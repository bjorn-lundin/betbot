
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- /home/bnl/bnlbot/botstart/bot-1-1/script/tcl/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_io, General_Routines, Text_Io;
with Ada.Strings.Fixed;

package body Table_History is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  -- Index 
  Stm_Select_Count_Sportsid ,
  Stm_Select_Sportsid ,
  Stm_Delete_Sportsid ,
  Stm_Select_Sportsid_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Eventid ,
  Stm_Select_Eventid ,
  Stm_Delete_Eventid ,
  Stm_Select_Eventid_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Event ,
  Stm_Select_Event ,
  Stm_Delete_Event ,
  Stm_Select_Event_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Country ,
  Stm_Select_Country ,
  Stm_Delete_Country ,
  Stm_Select_Country_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Latesttaken ,
  Stm_Select_Latesttaken ,
  Stm_Delete_Latesttaken ,
  Stm_Select_Latesttaken_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Eventid_selectionid_latesttaken ,
  Stm_Select_Eventid_selectionid_latesttaken ,
  Stm_Delete_Eventid_selectionid_latesttaken ,
  Stm_Select_Eventid_selectionid_latesttaken_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Eventid_selectionid ,
  Stm_Select_Eventid_selectionid ,
  Stm_Delete_Eventid_selectionid ,
  Stm_Select_Eventid_selectionid_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Fulldescription ,
  Stm_Select_Fulldescription ,
  Stm_Delete_Fulldescription ,
  Stm_Select_Fulldescription_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Firsttaken ,
  Stm_Select_Firsttaken ,
  Stm_Delete_Firsttaken ,
  Stm_Select_Firsttaken_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Eventid_selectionid_firsttaken ,
  Stm_Select_Eventid_selectionid_firsttaken ,
  Stm_Delete_Eventid_selectionid_firsttaken ,
  Stm_Select_Eventid_selectionid_firsttaken_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Scheduledoff ,
  Stm_Select_Scheduledoff ,
  Stm_Delete_Scheduledoff ,
  Stm_Select_Scheduledoff_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Scheduledoff_selectionid_firsttaken ,
  Stm_Select_Scheduledoff_selectionid_firsttaken ,
  Stm_Delete_Scheduledoff_selectionid_firsttaken ,
  Stm_Select_Scheduledoff_selectionid_firsttaken_O : Sql.Statement_Type;


  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_History.Data_Type is
    Data : Table_History.Data_Type;
  begin
    if not Sql.Is_Null(Stm, "PK") then
      Sql.Get(Stm, "PK", Data.Pk);
    else
      Data.Pk := 0;
    end if;
    if not Sql.Is_Null(Stm, "SPORTSID") then
      Sql.Get(Stm, "SPORTSID", Data.Sportsid);
    else
      Data.Sportsid := 0;
    end if;
    if not Sql.Is_Null(Stm, "EVENTID") then
      Sql.Get(Stm, "EVENTID", Data.Eventid);
    else
      Data.Eventid := 0;
    end if;
    if not Sql.Is_Null(Stm, "SETTLEDDATE") then
      Sql.Get_Timestamp(Stm, "SETTLEDDATE", Data.Settleddate);
    else
      Data.Settleddate := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "COUNTRY") then
      Sql.Get(Stm, "COUNTRY", Data.Country);
    else
      Data.Country := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "FULLDESCRIPTION") then
      Sql.Get(Stm, "FULLDESCRIPTION", Data.Fulldescription);
    else
      Data.Fulldescription := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "COURSE") then
      Sql.Get(Stm, "COURSE", Data.Course);
    else
      Data.Course := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "SCHEDULEDOFF") then
      Sql.Get_Timestamp(Stm, "SCHEDULEDOFF", Data.Scheduledoff);
    else
      Data.Scheduledoff := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "EVENT") then
      Sql.Get(Stm, "EVENT", Data.Event);
    else
      Data.Event := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "SELECTIONID") then
      Sql.Get(Stm, "SELECTIONID", Data.Selectionid);
    else
      Data.Selectionid := 0;
    end if;
    if not Sql.Is_Null(Stm, "SELECTION") then
      Sql.Get(Stm, "SELECTION", Data.Selection);
    else
      Data.Selection := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "ODDS") then
      Sql.Get(Stm, "ODDS", Data.Odds);
    else
      Data.Odds := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "NUMBERBETS") then
      Sql.Get(Stm, "NUMBERBETS", Data.Numberbets);
    else
      Data.Numberbets := 0;
    end if;
    if not Sql.Is_Null(Stm, "VOLUMEMATCHED") then
      Sql.Get(Stm, "VOLUMEMATCHED", Data.Volumematched);
    else
      Data.Volumematched := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "LATESTTAKEN") then
      Sql.Get_Timestamp(Stm, "LATESTTAKEN", Data.Latesttaken);
    else
      Data.Latesttaken := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "FIRSTTAKEN") then
      Sql.Get_Timestamp(Stm, "FIRSTTAKEN", Data.Firsttaken);
    else
      Data.Firsttaken := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "WINFLAG") then
      Sql.Get(Stm, "WINFLAG", Data.Winflag);
    else
      Data.Winflag := False;
    end if;
    if not Sql.Is_Null(Stm, "INPLAY") then
      Sql.Get(Stm, "INPLAY", Data.Inplay);
    else
      Data.Inplay := (others => ' ');
    end if;
  return Data;
  end Get;
---------------------------------------------

  function Get(Pk : Integer_4) return Table_History.Data_Type is
    Data       : Table_History.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Pk := Pk;
    Read(Data, End_Of_Set);
    return Data;
  end Get;
--------------------------------------------

  procedure Read_All(List  : in out History_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_All_O, "select * from HISTORY order by PK");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Sql.Prepare(Stm_Select_All, "select * from HISTORY");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_All;
--------------------------------------------


  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out History_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Count       : Integer_4 := 0;
    Data        : Table_History.Data_Type;
    Eos         : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Open_Cursor(Stm);
    loop
      Sql.Fetch(Stm, Eos); 
      exit when Eos or Count > Max;
      Data := Get(Stm);
      History_List_Pack.Insert_At_Tail(List, Data);
      Count := Count +1;
    end loop;
    Sql.Close_Cursor(Stm);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_List;
--------------------------------------------

  function Is_Existing(Pk : Integer_4) return Boolean is
    Data       : Table_History.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Pk := Pk;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;
--------------------------------------------

  procedure Read(Data       : in out Table_History.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select, " select * from HISTORY " & 
            "where PK=:PK" ) ;
    Sql.Set(Stm_Select, "PK", Data.Pk);

    Sql.Open_Cursor(Stm_Select);
    Sql.Fetch(Stm_Select, End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Sql.Close_Cursor(Stm_Select);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read;
---------------------------------------------

  procedure Delete(Data : in Table_History.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete, " delete from HISTORY " & 
            "where PK=:PK" ) ;
    Sql.Set(Stm_Delete, "PK", Data.Pk);

    Sql.Execute(Stm_Delete);
  end Delete;
--------------------------------------------

  procedure Update(Data : in out Table_History.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Sql.Prepare(Stm_Update, "update HISTORY set " &
            "SPORTSID=:SPORTSID," &
            "EVENTID=:EVENTID," &
            "SETTLEDDATE=:SETTLEDDATE," &
            "COUNTRY=:COUNTRY," &
            "FULLDESCRIPTION=:FULLDESCRIPTION," &
            "COURSE=:COURSE," &
            "SCHEDULEDOFF=:SCHEDULEDOFF," &
            "EVENT=:EVENT," &
            "SELECTIONID=:SELECTIONID," &
            "SELECTION=:SELECTION," &
            "ODDS=:ODDS," &
            "NUMBERBETS=:NUMBERBETS," &
            "VOLUMEMATCHED=:VOLUMEMATCHED," &
            "LATESTTAKEN=:LATESTTAKEN," &
            "FIRSTTAKEN=:FIRSTTAKEN," &
            "WINFLAG=:WINFLAG," &
            "INPLAY=:INPLAY " &
            "where PK=:PK " ) ;
    Sql.Set(Stm_Update, "PK",Data.Pk);
    Sql.Set(Stm_Update, "SPORTSID",Data.Sportsid);
    Sql.Set(Stm_Update, "EVENTID",Data.Eventid);
    Sql.Set_Timestamp(Stm_Update, "SETTLEDDATE",Data.Settleddate);
    if Data.Country = (Data.Country'Range => ' ') then
      Sql.Set_Null(Stm_Update, "COUNTRY");
    else
      Sql.Set(Stm_Update, "COUNTRY",Data.Country);
    end if;
    Sql.Set(Stm_Update, "FULLDESCRIPTION",Data.Fulldescription);
    if Data.Course = (Data.Course'Range => ' ') then
      Sql.Set_Null(Stm_Update, "COURSE");
    else
      Sql.Set(Stm_Update, "COURSE",Data.Course);
    end if;
    Sql.Set_Timestamp(Stm_Update, "SCHEDULEDOFF",Data.Scheduledoff);
    Sql.Set(Stm_Update, "EVENT",Data.Event);
    Sql.Set(Stm_Update, "SELECTIONID",Data.Selectionid);
    Sql.Set(Stm_Update, "SELECTION",Data.Selection);
    Sql.Set(Stm_Update, "ODDS",Data.Odds);
    Sql.Set(Stm_Update, "NUMBERBETS",Data.Numberbets);
    Sql.Set(Stm_Update, "VOLUMEMATCHED",Data.Volumematched);
    Sql.Set_Timestamp(Stm_Update, "LATESTTAKEN",Data.Latesttaken);
    Sql.Set_Timestamp(Stm_Update, "FIRSTTAKEN",Data.Firsttaken);
    Sql.Set(Stm_Update, "WINFLAG",Data.Winflag);
    Sql.Set(Stm_Update, "INPLAY",Data.Inplay);

    Sql.Execute(Stm_Update);
  end Update;
--------------------------------------------

  procedure Insert(Data : in out Table_History.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      null; --for tables without IXX*
    end if;
    Sql.Prepare(Stm_Insert, "insert into HISTORY values (" &
            ":PK, " &
            ":SPORTSID, " &
            ":EVENTID, " &
            ":SETTLEDDATE, " &
            ":COUNTRY, " &
            ":FULLDESCRIPTION, " &
            ":COURSE, " &
            ":SCHEDULEDOFF, " &
            ":EVENT, " &
            ":SELECTIONID, " &
            ":SELECTION, " &
            ":ODDS, " &
            ":NUMBERBETS, " &
            ":VOLUMEMATCHED, " &
            ":LATESTTAKEN, " &
            ":FIRSTTAKEN, " &
            ":WINFLAG, " &
            ":INPLAY) " ) ;
    Sql.Set(Stm_Insert, "PK",Data.Pk);
    Sql.Set(Stm_Insert, "SPORTSID",Data.Sportsid);
    Sql.Set(Stm_Insert, "EVENTID",Data.Eventid);
    Sql.Set_Timestamp(Stm_Insert, "SETTLEDDATE",Data.Settleddate);
    if Data.Country = (Data.Country'Range => ' ') then
      Sql.Set_Null(Stm_Insert, "COUNTRY");
    else
      Sql.Set(Stm_Insert, "COUNTRY",Data.Country);
    end if;
    Sql.Set(Stm_Insert, "FULLDESCRIPTION",Data.Fulldescription);
    if Data.Course = (Data.Course'Range => ' ') then
      Sql.Set_Null(Stm_Insert, "COURSE");
    else
      Sql.Set(Stm_Insert, "COURSE",Data.Course);
    end if;
    Sql.Set_Timestamp(Stm_Insert, "SCHEDULEDOFF",Data.Scheduledoff);
    Sql.Set(Stm_Insert, "EVENT",Data.Event);
    Sql.Set(Stm_Insert, "SELECTIONID",Data.Selectionid);
    Sql.Set(Stm_Insert, "SELECTION",Data.Selection);
    Sql.Set(Stm_Insert, "ODDS",Data.Odds);
    Sql.Set(Stm_Insert, "NUMBERBETS",Data.Numberbets);
    Sql.Set(Stm_Insert, "VOLUMEMATCHED",Data.Volumematched);
    Sql.Set_Timestamp(Stm_Insert, "LATESTTAKEN",Data.Latesttaken);
    Sql.Set_Timestamp(Stm_Insert, "FIRSTTAKEN",Data.Firsttaken);
    Sql.Set(Stm_Insert, "WINFLAG",Data.Winflag);
    Sql.Set(Stm_Insert, "INPLAY",Data.Inplay);

    Sql.Execute(Stm_Insert);
  end Insert;
--------------------------------------------

  -- Primary key, when several fields

  -- Index 

  procedure Read_Sportsid(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Sportsid_O, " select * from HISTORY " & 
            "where SPORTSID=:SPORTSID" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Sportsid_O, "SPORTSID", Data.Sportsid);
 
      Read_List(Stm_Select_Sportsid_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Sportsid, " select * from HISTORY " & 
            "where SPORTSID=:SPORTSID"  ) ; 
      Sql.Set(Stm_Select_Sportsid, "SPORTSID", Data.Sportsid);
 
      Read_List(Stm_Select_Sportsid, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Sportsid;
---------------------------------------------
  procedure Read_One_Sportsid(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Sportsid(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Sportsid;
---------------------------------------------

  function Count_Sportsid(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Sportsid, "select count('a') from HISTORY where SPORTSID = :SPORTSID ");
    Sql.Set(Stm_Select_Count_Sportsid, "SPORTSID", Data.Sportsid);
 
    Sql.Open_Cursor(Stm_Select_Count_Sportsid);
    Sql.Fetch(Stm_Select_Count_Sportsid, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Sportsid, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Sportsid);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Sportsid;
---------------------------------------------
  procedure Delete_Sportsid(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Sportsid, " delete from HISTORY " & 
            "where SPORTSID=:SPORTSID"  ) ; 
      Sql.Set(Stm_Delete_Sportsid, "SPORTSID", Data.Sportsid);
 
    Sql.Execute(Stm_Delete_Sportsid);
  end Delete_Sportsid;
---------------------------------------------


  -- Index 

  procedure Read_Eventid(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventid_O, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Eventid_O, "EVENTID", Data.Eventid);
 
      Read_List(Stm_Select_Eventid_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventid, " select * from HISTORY " & 
            "where EVENTID=:EVENTID"  ) ; 
      Sql.Set(Stm_Select_Eventid, "EVENTID", Data.Eventid);
 
      Read_List(Stm_Select_Eventid, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventid;
---------------------------------------------
  procedure Read_One_Eventid(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Eventid(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Eventid;
---------------------------------------------

  function Count_Eventid(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventid, "select count('a') from HISTORY where EVENTID = :EVENTID ");
    Sql.Set(Stm_Select_Count_Eventid, "EVENTID", Data.Eventid);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventid);
    Sql.Fetch(Stm_Select_Count_Eventid, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventid, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventid);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventid;
---------------------------------------------
  procedure Delete_Eventid(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventid, " delete from HISTORY " & 
            "where EVENTID=:EVENTID"  ) ; 
      Sql.Set(Stm_Delete_Eventid, "EVENTID", Data.Eventid);
 
    Sql.Execute(Stm_Delete_Eventid);
  end Delete_Eventid;
---------------------------------------------


  -- Index 

  procedure Read_Event(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Event_O, " select * from HISTORY " & 
            "where EVENT=:EVENT" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Event_O, "EVENT", Data.Event);
 
      Read_List(Stm_Select_Event_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Event, " select * from HISTORY " & 
            "where EVENT=:EVENT"  ) ; 
      Sql.Set(Stm_Select_Event, "EVENT", Data.Event);
 
      Read_List(Stm_Select_Event, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Event;
---------------------------------------------
  procedure Read_One_Event(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Event(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Event;
---------------------------------------------

  function Count_Event(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Event, "select count('a') from HISTORY where EVENT = :EVENT ");
    Sql.Set(Stm_Select_Count_Event, "EVENT", Data.Event);
 
    Sql.Open_Cursor(Stm_Select_Count_Event);
    Sql.Fetch(Stm_Select_Count_Event, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Event, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Event);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Event;
---------------------------------------------
  procedure Delete_Event(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Event, " delete from HISTORY " & 
            "where EVENT=:EVENT"  ) ; 
      Sql.Set(Stm_Delete_Event, "EVENT", Data.Event);
 
    Sql.Execute(Stm_Delete_Event);
  end Delete_Event;
---------------------------------------------


  -- Index 

  procedure Read_Country(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Country_O, " select * from HISTORY " & 
            "where COUNTRY=:COUNTRY" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Country_O, "COUNTRY", Data.Country);
 
      Read_List(Stm_Select_Country_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Country, " select * from HISTORY " & 
            "where COUNTRY=:COUNTRY"  ) ; 
      Sql.Set(Stm_Select_Country, "COUNTRY", Data.Country);
 
      Read_List(Stm_Select_Country, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Country;
---------------------------------------------
  procedure Read_One_Country(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Country(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Country;
---------------------------------------------

  function Count_Country(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Country, "select count('a') from HISTORY where COUNTRY = :COUNTRY ");
    Sql.Set(Stm_Select_Count_Country, "COUNTRY", Data.Country);
 
    Sql.Open_Cursor(Stm_Select_Count_Country);
    Sql.Fetch(Stm_Select_Count_Country, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Country, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Country);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Country;
---------------------------------------------
  procedure Delete_Country(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Country, " delete from HISTORY " & 
            "where COUNTRY=:COUNTRY"  ) ; 
      Sql.Set(Stm_Delete_Country, "COUNTRY", Data.Country);
 
    Sql.Execute(Stm_Delete_Country);
  end Delete_Country;
---------------------------------------------


  -- Index 

  procedure Read_Latesttaken(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Latesttaken_O, " select * from HISTORY " & 
            "where LATESTTAKEN=:LATESTTAKEN" &
            " order by PK "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Latesttaken_O,"LATESTTAKEN", Data.Latesttaken);
 
      Read_List(Stm_Select_Latesttaken_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Latesttaken, " select * from HISTORY " & 
            "where LATESTTAKEN=:LATESTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
      Read_List(Stm_Select_Latesttaken, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Latesttaken;
---------------------------------------------
  procedure Read_One_Latesttaken(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Latesttaken(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Latesttaken;
---------------------------------------------

  function Count_Latesttaken(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Latesttaken, "select count('a') from HISTORY where LATESTTAKEN = :LATESTTAKEN ");
    Sql.Set_Timestamp(Stm_Select_Count_Latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
    Sql.Open_Cursor(Stm_Select_Count_Latesttaken);
    Sql.Fetch(Stm_Select_Count_Latesttaken, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Latesttaken, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Latesttaken);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Latesttaken;
---------------------------------------------
  procedure Delete_Latesttaken(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Latesttaken, " delete from HISTORY " & 
            "where LATESTTAKEN=:LATESTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
    Sql.Execute(Stm_Delete_Latesttaken);
  end Delete_Latesttaken;
---------------------------------------------


  -- Index 

  procedure Read_Eventid_selectionid_latesttaken(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventid_selectionid_latesttaken_O, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and LATESTTAKEN=:LATESTTAKEN" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid_latesttaken_O, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid_latesttaken_O, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Eventid_selectionid_latesttaken_O,"LATESTTAKEN", Data.Latesttaken);
 
      Read_List(Stm_Select_Eventid_selectionid_latesttaken_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventid_selectionid_latesttaken, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and LATESTTAKEN=:LATESTTAKEN"  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid_latesttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid_latesttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Eventid_selectionid_latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
      Read_List(Stm_Select_Eventid_selectionid_latesttaken, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventid_selectionid_latesttaken;
---------------------------------------------
  procedure Read_One_Eventid_selectionid_latesttaken(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Eventid_selectionid_latesttaken(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Eventid_selectionid_latesttaken;
---------------------------------------------

  function Count_Eventid_selectionid_latesttaken(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventid_selectionid_latesttaken, "select count('a') from HISTORY where EVENTID_SELECTIONID_LATESTTAKEN = :EVENTID_SELECTIONID_LATESTTAKEN ");
    Sql.Set(Stm_Select_Count_Eventid_selectionid_latesttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Count_Eventid_selectionid_latesttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Count_Eventid_selectionid_latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventid_selectionid_latesttaken);
    Sql.Fetch(Stm_Select_Count_Eventid_selectionid_latesttaken, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventid_selectionid_latesttaken, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventid_selectionid_latesttaken);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventid_selectionid_latesttaken;
---------------------------------------------
  procedure Delete_Eventid_selectionid_latesttaken(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventid_selectionid_latesttaken, " delete from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and LATESTTAKEN=:LATESTTAKEN"  ) ; 
      Sql.Set(Stm_Delete_Eventid_selectionid_latesttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Delete_Eventid_selectionid_latesttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Delete_Eventid_selectionid_latesttaken,"LATESTTAKEN", Data.Latesttaken);
 
    Sql.Execute(Stm_Delete_Eventid_selectionid_latesttaken);
  end Delete_Eventid_selectionid_latesttaken;
---------------------------------------------


  -- Index 

  procedure Read_Eventid_selectionid(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventid_selectionid_O, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid_O, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid_O, "SELECTIONID", Data.Selectionid);
 
      Read_List(Stm_Select_Eventid_selectionid_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventid_selectionid, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID"  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid, "SELECTIONID", Data.Selectionid);
 
      Read_List(Stm_Select_Eventid_selectionid, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventid_selectionid;
---------------------------------------------
  procedure Read_One_Eventid_selectionid(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Eventid_selectionid(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Eventid_selectionid;
---------------------------------------------

  function Count_Eventid_selectionid(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventid_selectionid, "select count('a') from HISTORY where EVENTID_SELECTIONID = :EVENTID_SELECTIONID ");
    Sql.Set(Stm_Select_Count_Eventid_selectionid, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Count_Eventid_selectionid, "SELECTIONID", Data.Selectionid);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventid_selectionid);
    Sql.Fetch(Stm_Select_Count_Eventid_selectionid, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventid_selectionid, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventid_selectionid);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventid_selectionid;
---------------------------------------------
  procedure Delete_Eventid_selectionid(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventid_selectionid, " delete from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID"  ) ; 
      Sql.Set(Stm_Delete_Eventid_selectionid, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Delete_Eventid_selectionid, "SELECTIONID", Data.Selectionid);
 
    Sql.Execute(Stm_Delete_Eventid_selectionid);
  end Delete_Eventid_selectionid;
---------------------------------------------


  -- Index 

  procedure Read_Fulldescription(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Fulldescription_O, " select * from HISTORY " & 
            "where FULLDESCRIPTION=:FULLDESCRIPTION" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Fulldescription_O, "FULLDESCRIPTION", Data.Fulldescription);
 
      Read_List(Stm_Select_Fulldescription_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Fulldescription, " select * from HISTORY " & 
            "where FULLDESCRIPTION=:FULLDESCRIPTION"  ) ; 
      Sql.Set(Stm_Select_Fulldescription, "FULLDESCRIPTION", Data.Fulldescription);
 
      Read_List(Stm_Select_Fulldescription, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Fulldescription;
---------------------------------------------
  procedure Read_One_Fulldescription(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Fulldescription(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Fulldescription;
---------------------------------------------

  function Count_Fulldescription(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Fulldescription, "select count('a') from HISTORY where FULLDESCRIPTION = :FULLDESCRIPTION ");
    Sql.Set(Stm_Select_Count_Fulldescription, "FULLDESCRIPTION", Data.Fulldescription);
 
    Sql.Open_Cursor(Stm_Select_Count_Fulldescription);
    Sql.Fetch(Stm_Select_Count_Fulldescription, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Fulldescription, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Fulldescription);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Fulldescription;
---------------------------------------------
  procedure Delete_Fulldescription(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Fulldescription, " delete from HISTORY " & 
            "where FULLDESCRIPTION=:FULLDESCRIPTION"  ) ; 
      Sql.Set(Stm_Delete_Fulldescription, "FULLDESCRIPTION", Data.Fulldescription);
 
    Sql.Execute(Stm_Delete_Fulldescription);
  end Delete_Fulldescription;
---------------------------------------------


  -- Index 

  procedure Read_Firsttaken(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Firsttaken_O, " select * from HISTORY " & 
            "where FIRSTTAKEN=:FIRSTTAKEN" &
            " order by PK "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Firsttaken_O,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Firsttaken_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Firsttaken, " select * from HISTORY " & 
            "where FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Firsttaken, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Firsttaken;
---------------------------------------------
  procedure Read_One_Firsttaken(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Firsttaken(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Firsttaken;
---------------------------------------------

  function Count_Firsttaken(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Firsttaken, "select count('a') from HISTORY where FIRSTTAKEN = :FIRSTTAKEN ");
    Sql.Set_Timestamp(Stm_Select_Count_Firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Open_Cursor(Stm_Select_Count_Firsttaken);
    Sql.Fetch(Stm_Select_Count_Firsttaken, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Firsttaken, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Firsttaken);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Firsttaken;
---------------------------------------------
  procedure Delete_Firsttaken(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Firsttaken, " delete from HISTORY " & 
            "where FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Execute(Stm_Delete_Firsttaken);
  end Delete_Firsttaken;
---------------------------------------------


  -- Index 

  procedure Read_Eventid_selectionid_firsttaken(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventid_selectionid_firsttaken_O, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN" &
            " order by PK "  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid_firsttaken_O, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid_firsttaken_O, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Eventid_selectionid_firsttaken_O,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Eventid_selectionid_firsttaken_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventid_selectionid_firsttaken, " select * from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set(Stm_Select_Eventid_selectionid_firsttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Eventid_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Eventid_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Eventid_selectionid_firsttaken, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventid_selectionid_firsttaken;
---------------------------------------------
  procedure Read_One_Eventid_selectionid_firsttaken(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Eventid_selectionid_firsttaken(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Eventid_selectionid_firsttaken;
---------------------------------------------

  function Count_Eventid_selectionid_firsttaken(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventid_selectionid_firsttaken, "select count('a') from HISTORY where EVENTID_SELECTIONID_FIRSTTAKEN = :EVENTID_SELECTIONID_FIRSTTAKEN ");
    Sql.Set(Stm_Select_Count_Eventid_selectionid_firsttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Select_Count_Eventid_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Count_Eventid_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventid_selectionid_firsttaken);
    Sql.Fetch(Stm_Select_Count_Eventid_selectionid_firsttaken, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventid_selectionid_firsttaken, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventid_selectionid_firsttaken);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventid_selectionid_firsttaken;
---------------------------------------------
  procedure Delete_Eventid_selectionid_firsttaken(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventid_selectionid_firsttaken, " delete from HISTORY " & 
            "where EVENTID=:EVENTID" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set(Stm_Delete_Eventid_selectionid_firsttaken, "EVENTID", Data.Eventid);
    Sql.Set(Stm_Delete_Eventid_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Delete_Eventid_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Execute(Stm_Delete_Eventid_selectionid_firsttaken);
  end Delete_Eventid_selectionid_firsttaken;
---------------------------------------------


  -- Index 

  procedure Read_Scheduledoff(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Scheduledoff_O, " select * from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF" &
            " order by PK "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Scheduledoff_O,"SCHEDULEDOFF", Data.Scheduledoff);
 
      Read_List(Stm_Select_Scheduledoff_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Scheduledoff, " select * from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Scheduledoff,"SCHEDULEDOFF", Data.Scheduledoff);
 
      Read_List(Stm_Select_Scheduledoff, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Scheduledoff;
---------------------------------------------
  procedure Read_One_Scheduledoff(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Scheduledoff(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Scheduledoff;
---------------------------------------------

  function Count_Scheduledoff(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Scheduledoff, "select count('a') from HISTORY where SCHEDULEDOFF = :SCHEDULEDOFF ");
    Sql.Set_Timestamp(Stm_Select_Count_Scheduledoff,"SCHEDULEDOFF", Data.Scheduledoff);
 
    Sql.Open_Cursor(Stm_Select_Count_Scheduledoff);
    Sql.Fetch(Stm_Select_Count_Scheduledoff, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Scheduledoff, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Scheduledoff);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Scheduledoff;
---------------------------------------------
  procedure Delete_Scheduledoff(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Scheduledoff, " delete from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Scheduledoff,"SCHEDULEDOFF", Data.Scheduledoff);
 
    Sql.Execute(Stm_Delete_Scheduledoff);
  end Delete_Scheduledoff;
---------------------------------------------


  -- Index 

  procedure Read_Scheduledoff_selectionid_firsttaken(Data  : in     Table_History.Data_Type;
                       List  : in out History_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Scheduledoff_selectionid_firsttaken_O, " select * from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN" &
            " order by PK "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Scheduledoff_selectionid_firsttaken_O,"SCHEDULEDOFF", Data.Scheduledoff);
    Sql.Set(Stm_Select_Scheduledoff_selectionid_firsttaken_O, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Scheduledoff_selectionid_firsttaken_O,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Scheduledoff_selectionid_firsttaken_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Scheduledoff_selectionid_firsttaken, " select * from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Scheduledoff_selectionid_firsttaken,"SCHEDULEDOFF", Data.Scheduledoff);
    Sql.Set(Stm_Select_Scheduledoff_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Scheduledoff_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
      Read_List(Stm_Select_Scheduledoff_selectionid_firsttaken, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Scheduledoff_selectionid_firsttaken;
---------------------------------------------
  procedure Read_One_Scheduledoff_selectionid_firsttaken(Data       : in out Table_History.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : History_List_Pack.List_Type := History_List_Pack.Create;
  begin
    Read_Scheduledoff_selectionid_firsttaken(Data, List, Order, 1);
    if History_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      History_List_Pack.Remove_From_Head(List, Data);
    end if;
    History_List_Pack.Release(List);
    end Read_One_Scheduledoff_selectionid_firsttaken;
---------------------------------------------

  function Count_Scheduledoff_selectionid_firsttaken(Data : Table_History.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Scheduledoff_selectionid_firsttaken, "select count('a') from HISTORY where SCHEDULEDOFF_SELECTIONID_FIRSTTAKEN = :SCHEDULEDOFF_SELECTIONID_FIRSTTAKEN ");
    Sql.Set_Timestamp(Stm_Select_Count_Scheduledoff_selectionid_firsttaken,"SCHEDULEDOFF", Data.Scheduledoff);
    Sql.Set(Stm_Select_Count_Scheduledoff_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Select_Count_Scheduledoff_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Open_Cursor(Stm_Select_Count_Scheduledoff_selectionid_firsttaken);
    Sql.Fetch(Stm_Select_Count_Scheduledoff_selectionid_firsttaken, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Scheduledoff_selectionid_firsttaken, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Scheduledoff_selectionid_firsttaken);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Scheduledoff_selectionid_firsttaken;
---------------------------------------------
  procedure Delete_Scheduledoff_selectionid_firsttaken(Data  : in     Table_History.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Scheduledoff_selectionid_firsttaken, " delete from HISTORY " & 
            "where SCHEDULEDOFF=:SCHEDULEDOFF" &
            " and SELECTIONID=:SELECTIONID" &
            " and FIRSTTAKEN=:FIRSTTAKEN"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Scheduledoff_selectionid_firsttaken,"SCHEDULEDOFF", Data.Scheduledoff);
    Sql.Set(Stm_Delete_Scheduledoff_selectionid_firsttaken, "SELECTIONID", Data.Selectionid);
    Sql.Set_Timestamp(Stm_Delete_Scheduledoff_selectionid_firsttaken,"FIRSTTAKEN", Data.Firsttaken);
 
    Sql.Execute(Stm_Delete_Scheduledoff_selectionid_firsttaken);
  end Delete_Scheduledoff_selectionid_firsttaken;
---------------------------------------------



  -- Procedures for all DBMS


  function Date_To_String(Date : in Sattmate_Calendar.Time_Type) return String is
    package Integer_2_Io is new Text_Io.Integer_Io(Integer_2);
    Date_String : String(1..10) := "yyyy-mm-dd";
  begin
    Integer_2_Io.Put(Date_String(9..10), Date.Day);
    Integer_2_Io.Put(Date_String(6..7), Date.Month);
    Integer_2_Io.Put(Date_String(1..4), Date.Year);
    if Date_String(9) = ' ' then Date_String(9) := '0'; end if;
    if Date_String(6) = ' ' then Date_String(6) := '0'; end if;
    return Date_String;
  end Date_To_String;
--------------------------------------------



  function To_String(Data : in Table_History.Data_Type) return String is
  begin
    return
          " Pk = " & Integer_4'Image(Data.Pk) &
          " Sportsid = " & Integer_4'Image(Data.Sportsid) &
          " Eventid = " & Integer_4'Image(Data.Eventid) &
          " Settleddate = " & Sattmate_Calendar.String_Date_And_Time(Data.Settleddate, Milliseconds => true) &
          " Country = " & General_Routines.Skip_Trailing_Blanks(Data.Country) &
          " Fulldescription = " & General_Routines.Skip_Trailing_Blanks(Data.Fulldescription) &
          " Course = " & General_Routines.Skip_Trailing_Blanks(Data.Course) &
          " Scheduledoff = " & Sattmate_Calendar.String_Date_And_Time(Data.Scheduledoff, Milliseconds => true) &
          " Event = " & General_Routines.Skip_Trailing_Blanks(Data.Event) &
          " Selectionid = " & Integer_4'Image(Data.Selectionid) &
          " Selection = " & General_Routines.Skip_Trailing_Blanks(Data.Selection) &
          " Odds = " &  General_Routines.F8_Image(Data.Odds) &
          " Numberbets = " & Integer_4'Image(Data.Numberbets) &
          " Volumematched = " &  General_Routines.F8_Image(Data.Volumematched) &
          " Latesttaken = " & Sattmate_Calendar.String_Date_And_Time(Data.Latesttaken, Milliseconds => true) &
          " Firsttaken = " & Sattmate_Calendar.String_Date_And_Time(Data.Firsttaken, Milliseconds => true) &
          " Winflag = " & Boolean'Image(Data.Winflag) &
          " Inplay = " & General_Routines.Skip_Trailing_Blanks(Data.Inplay) &
          "";
  end To_String;
--------------------------------------------

end Table_History ;

