
-----------------------------------------------------
-- This file is AUTOGENERATED by
-- c:/bnl/svn/wcs-std/sattmate/script/local/make_table_package.tcl at
--9.6-10510
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!-----
-----------DO NOT EDIT THIS FILE!!!!----------------
-----------------------------------------------------




pragma Warnings (Off);
with General_Routines, Text_Io;
with Ada.Strings.Fixed;

package body Table_Dry_Markets is

   Stm_Select,
   Stm_Delete,
   Stm_Update,
   Stm_Insert,
   Stm_Select_All,
   Stm_Select_All_O  : Sql.Statement_Type;


   -- Index
   Stm_Select_Count_Event_Date ,
   Stm_Select_Event_Date ,
   Stm_Delete_Event_Date ,
   Stm_Select_Event_Date_O : Sql.Statement_Type;

   -- Index
   Stm_Select_Count_Event_Hierarchy ,
   Stm_Select_Event_Hierarchy ,
   Stm_Delete_Event_Hierarchy ,
   Stm_Select_Event_Hierarchy_O : Sql.Statement_Type;

   -- Index
   Stm_Select_Count_Market_Name ,
   Stm_Select_Market_Name ,
   Stm_Delete_Market_Name ,
   Stm_Select_Market_Name_O : Sql.Statement_Type;


   -- Procedures for DBMS DEF
   -- Primary key
   function Get (Stm : in Sql.Statement_Type) return Table_Dry_Markets.Data_Type is
      Data : Table_Dry_Markets.Data_Type;
   begin
      if not Sql.Is_Null (Stm, "MARKET_ID") then
         Sql.Get (Stm, "MARKET_ID", Data.Market_Id);
      else
         Data.Market_Id := 0;
      end if;
      if not Sql.Is_Null (Stm, "BSP_MARKET") then
         Sql.Get (Stm, "BSP_MARKET", Data.Bsp_Market);
      else
         Data.Bsp_Market := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "MARKET_TYPE") then
         Sql.Get (Stm, "MARKET_TYPE", Data.Market_Type);
      else
         Data.Market_Type := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "EVENT_HIERARCHY") then
         Sql.Get (Stm, "EVENT_HIERARCHY", Data.Event_Hierarchy);
      else
         Data.Event_Hierarchy := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "LAST_REFRESH") then
         Sql.Get_Timestamp (Stm, "LAST_REFRESH", Data.Last_Refresh);
      else
         Data.Last_Refresh := Time_Type_First;
      end if;
      if not Sql.Is_Null (Stm, "TURNING_IN_PLAY") then
         Sql.Get (Stm, "TURNING_IN_PLAY", Data.Turning_In_Play);
      else
         Data.Turning_In_Play := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "MENU_PATH") then
         Sql.Get (Stm, "MENU_PATH", Data.Menu_Path);
      else
         Data.Menu_Path := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "BET_DELAY") then
         Sql.Get (Stm, "BET_DELAY", Data.Bet_Delay);
      else
         Data.Bet_Delay := 0;
      end if;
      if not Sql.Is_Null (Stm, "EXCHANGE_ID") then
         Sql.Get (Stm, "EXCHANGE_ID", Data.Exchange_Id);
      else
         Data.Exchange_Id := 0;
      end if;
      if not Sql.Is_Null (Stm, "COUNTRY_CODE") then
         Sql.Get (Stm, "COUNTRY_CODE", Data.Country_Code);
      else
         Data.Country_Code := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "MARKET_NAME") then
         Sql.Get (Stm, "MARKET_NAME", Data.Market_Name);
      else
         Data.Market_Name := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "MARKET_STATUS") then
         Sql.Get (Stm, "MARKET_STATUS", Data.Market_Status);
      else
         Data.Market_Status := (others => ' ');
      end if;
      if not Sql.Is_Null (Stm, "EVENT_DATE") then
         Sql.Get_Timestamp (Stm, "EVENT_DATE", Data.Event_Date);
      else
         Data.Event_Date := Time_Type_First;
      end if;
      if not Sql.Is_Null (Stm, "NO_OF_RUNNERS") then
         Sql.Get (Stm, "NO_OF_RUNNERS", Data.No_Of_Runners);
      else
         Data.No_Of_Runners := 0;
      end if;
      if not Sql.Is_Null (Stm, "TOTAL_MATCHED") then
         Sql.Get (Stm, "TOTAL_MATCHED", Data.Total_Matched);
      else
         Data.Total_Matched := 0;
      end if;
      if not Sql.Is_Null (Stm, "NO_OF_WINNERS") then
         Sql.Get (Stm, "NO_OF_WINNERS", Data.No_Of_Winners);
      else
         Data.No_Of_Winners := 0;
      end if;
      return Data;
   end Get;
   ---------------------------------------------

   function Get (Market_Id : Integer_4) return Table_Dry_Markets.Data_Type is
      Data       : Table_Dry_Markets.Data_Type;
      End_Of_Set : Boolean := True;
   begin
      Data.Market_Id := Market_Id;
      Read (Data, End_Of_Set);
      return Data;
   end Get;
   --------------------------------------------

   procedure Read_All (List  : in out Dry_Markets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
      use Sql;
      Start_Trans  : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction  : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      if Order then
         Sql.Prepare (Stm_Select_All_O, "select * from DRY_MARKETS order by MARKET_ID");
         Read_List (Stm_Select_All_O, List, Max);
      else
         Sql.Prepare (Stm_Select_All, "select * from DRY_MARKETS");
         Read_List (Stm_Select_All, List, Max);
      end if;
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read_All;
   --------------------------------------------


   procedure Read_List (Stm  : in     Sql.Statement_Type;
                        List : in out Dry_Markets_List_Pack.List_Type;
                        Max  : in     Integer_4 := Integer_4'Last) is
      use Sql;
      Count        : Integer_4 := 0;
      Data         : Table_Dry_Markets.Data_Type;
      Eos          : Boolean := False;
      Start_Trans  : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction  : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      Sql.Open_Cursor (Stm);
      loop
         Sql.Fetch (Stm, Eos);
         exit when Eos or Count > Max;
         Data := Get (Stm);
         Dry_Markets_List_Pack.Insert_At_Tail (List, Data);
         Count := Count + 1;
      end loop;
      Sql.Close_Cursor (Stm);
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read_List;
   --------------------------------------------

   function Is_Existing (Market_Id : Integer_4) return Boolean is
      Data       : Table_Dry_Markets.Data_Type;
      End_Of_Set : Boolean := True;
   begin
      Data.Market_Id := Market_Id;
      Read (Data, End_Of_Set);
      return not End_Of_Set;
   end Is_Existing;
   --------------------------------------------

   procedure Read (Data       : in out Table_Dry_Markets.Data_Type;
                   End_Of_Set : in out Boolean) is
      use Sql;
      Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction   : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      Sql.Prepare (Stm_Select, " select * from DRY_MARKETS " &
                     "where MARKET_ID=:MARKET_ID" ) ;
      Sql.Set (Stm_Select, "MARKET_ID", Data.Market_Id);

      Sql.Open_Cursor (Stm_Select);
      Sql.Fetch (Stm_Select, End_Of_Set);
      if not End_Of_Set then
         Data := Get (Stm_Select);
      end if;
      Sql.Close_Cursor (Stm_Select);
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read;
   ---------------------------------------------

   procedure Delete (Data : in Table_Dry_Markets.Data_Type) is
   begin
      Sql.Prepare (Stm_Delete, " delete from DRY_MARKETS " &
                     "where MARKET_ID=:MARKET_ID" ) ;
      Sql.Set (Stm_Delete, "MARKET_ID", Data.Market_Id);

      Sql.Execute (Stm_Delete);
   end Delete;
   --------------------------------------------

   procedure Update (Data : in out Table_Dry_Markets.Data_Type; Keep_Timestamp : in Boolean := False) is
   begin
      Sql.Prepare (Stm_Update, "update DRY_MARKETS set " &
                     "BSP_MARKET=:BSP_MARKET," &
                     "MARKET_TYPE=:MARKET_TYPE," &
                     "EVENT_HIERARCHY=:EVENT_HIERARCHY," &
                     "LAST_REFRESH=:LAST_REFRESH," &
                     "TURNING_IN_PLAY=:TURNING_IN_PLAY," &
                     "MENU_PATH=:MENU_PATH," &
                     "BET_DELAY=:BET_DELAY," &
                     "EXCHANGE_ID=:EXCHANGE_ID," &
                     "COUNTRY_CODE=:COUNTRY_CODE," &
                     "MARKET_NAME=:MARKET_NAME," &
                     "MARKET_STATUS=:MARKET_STATUS," &
                     "EVENT_DATE=:EVENT_DATE," &
                     "NO_OF_RUNNERS=:NO_OF_RUNNERS," &
                     "TOTAL_MATCHED=:TOTAL_MATCHED," &
                     "NO_OF_WINNERS=:NO_OF_WINNERS " &
                     "where MARKET_ID=:MARKET_ID " ) ;
      Sql.Set (Stm_Update, "MARKET_ID", Data.Market_Id);
      Sql.Set (Stm_Update, "BSP_MARKET", Data.Bsp_Market);
      if Data.Market_Type = (Data.Market_Type'Range => ' ') then
         Sql.Set_Null (Stm_Update, "MARKET_TYPE");
      else
         Sql.Set (Stm_Update, "MARKET_TYPE", Data.Market_Type);
      end if;
      Sql.Set (Stm_Update, "EVENT_HIERARCHY", Data.Event_Hierarchy);
      Sql.Set_Timestamp (Stm_Update, "LAST_REFRESH", Data.Last_Refresh);
      Sql.Set (Stm_Update, "TURNING_IN_PLAY", Data.Turning_In_Play);
      if Data.Menu_Path = (Data.Menu_Path'Range => ' ') then
         Sql.Set_Null (Stm_Update, "MENU_PATH");
      else
         Sql.Set (Stm_Update, "MENU_PATH", Data.Menu_Path);
      end if;
      Sql.Set (Stm_Update, "BET_DELAY", Data.Bet_Delay);
      Sql.Set (Stm_Update, "EXCHANGE_ID", Data.Exchange_Id);
      Sql.Set (Stm_Update, "COUNTRY_CODE", Data.Country_Code);
      if Data.Market_Name = (Data.Market_Name'Range => ' ') then
         Sql.Set_Null (Stm_Update, "MARKET_NAME");
      else
         Sql.Set (Stm_Update, "MARKET_NAME", Data.Market_Name);
      end if;
      if Data.Market_Status = (Data.Market_Status'Range => ' ') then
         Sql.Set_Null (Stm_Update, "MARKET_STATUS");
      else
         Sql.Set (Stm_Update, "MARKET_STATUS", Data.Market_Status);
      end if;
      if Data.Event_Date = Time_Type_First then
         Sql.Set_Null_Date (Stm_Update, "EVENT_DATE");
      else
         Sql.Set_Timestamp (Stm_Update, "EVENT_DATE", Data.Event_Date);
      end if;
      if Data.No_Of_Runners = 0 then
         Sql.Set_Null (Stm_Update, "NO_OF_RUNNERS");
      else
         Sql.Set (Stm_Update, "NO_OF_RUNNERS", Data.No_Of_Runners);
      end if;
      if Data.Total_Matched = 0 then
         Sql.Set_Null (Stm_Update, "TOTAL_MATCHED");
      else
         Sql.Set (Stm_Update, "TOTAL_MATCHED", Data.Total_Matched);
      end if;
      if Data.No_Of_Winners = 0 then
         Sql.Set_Null (Stm_Update, "NO_OF_WINNERS");
      else
         Sql.Set (Stm_Update, "NO_OF_WINNERS", Data.No_Of_Winners);
      end if;

      Sql.Execute (Stm_Update);
   end Update;
   --------------------------------------------

   procedure Insert (Data : in out Table_Dry_Markets.Data_Type; Keep_Timestamp : in Boolean := False) is
   begin
      if not Keep_Timestamp then
         null; --for tables without IXX*
      end if;
      Sql.Prepare (Stm_Insert, "insert into DRY_MARKETS values (" &
                     ":MARKET_ID, " &
                     ":BSP_MARKET, " &
                     ":MARKET_TYPE, " &
                     ":EVENT_HIERARCHY, " &
                     ":LAST_REFRESH, " &
                     ":TURNING_IN_PLAY, " &
                     ":MENU_PATH, " &
                     ":BET_DELAY, " &
                     ":EXCHANGE_ID, " &
                     ":COUNTRY_CODE, " &
                     ":MARKET_NAME, " &
                     ":MARKET_STATUS, " &
                     ":EVENT_DATE, " &
                     ":NO_OF_RUNNERS, " &
                     ":TOTAL_MATCHED, " &
                     ":NO_OF_WINNERS) " ) ;
      Sql.Set (Stm_Insert, "MARKET_ID", Data.Market_Id);
      Sql.Set (Stm_Insert, "BSP_MARKET", Data.Bsp_Market);
      if Data.Market_Type = (Data.Market_Type'Range => ' ') then
         Sql.Set_Null (Stm_Insert, "MARKET_TYPE");
      else
         Sql.Set (Stm_Insert, "MARKET_TYPE", Data.Market_Type);
      end if;
      Sql.Set (Stm_Insert, "EVENT_HIERARCHY", Data.Event_Hierarchy);
      Sql.Set_Timestamp (Stm_Insert, "LAST_REFRESH", Data.Last_Refresh);
      Sql.Set (Stm_Insert, "TURNING_IN_PLAY", Data.Turning_In_Play);
      if Data.Menu_Path = (Data.Menu_Path'Range => ' ') then
         Sql.Set_Null (Stm_Insert, "MENU_PATH");
      else
         Sql.Set (Stm_Insert, "MENU_PATH", Data.Menu_Path);
      end if;
      Sql.Set (Stm_Insert, "BET_DELAY", Data.Bet_Delay);
      Sql.Set (Stm_Insert, "EXCHANGE_ID", Data.Exchange_Id);
      Sql.Set (Stm_Insert, "COUNTRY_CODE", Data.Country_Code);
      if Data.Market_Name = (Data.Market_Name'Range => ' ') then
         Sql.Set_Null (Stm_Insert, "MARKET_NAME");
      else
         Sql.Set (Stm_Insert, "MARKET_NAME", Data.Market_Name);
      end if;
      if Data.Market_Status = (Data.Market_Status'Range => ' ') then
         Sql.Set_Null (Stm_Insert, "MARKET_STATUS");
      else
         Sql.Set (Stm_Insert, "MARKET_STATUS", Data.Market_Status);
      end if;
      if Data.Event_Date = Time_Type_First then
         Sql.Set_Null_Date (Stm_Insert, "EVENT_DATE");
      else
         Sql.Set_Timestamp (Stm_Insert, "EVENT_DATE", Data.Event_Date);
      end if;
      if Data.No_Of_Runners = 0 then
         Sql.Set_Null (Stm_Insert, "NO_OF_RUNNERS");
      else
         Sql.Set (Stm_Insert, "NO_OF_RUNNERS", Data.No_Of_Runners);
      end if;
      if Data.Total_Matched = 0 then
         Sql.Set_Null (Stm_Insert, "TOTAL_MATCHED");
      else
         Sql.Set (Stm_Insert, "TOTAL_MATCHED", Data.Total_Matched);
      end if;
      if Data.No_Of_Winners = 0 then
         Sql.Set_Null (Stm_Insert, "NO_OF_WINNERS");
      else
         Sql.Set (Stm_Insert, "NO_OF_WINNERS", Data.No_Of_Winners);
      end if;

      Sql.Execute (Stm_Insert);
   end Insert;
   --------------------------------------------

   -- Primary key, when several fields

   -- Index

   procedure Read_Event_Date (Data  : in     Table_Dry_Markets.Data_Type;
                              List  : in out Dry_Markets_List_Pack.List_Type;
                              Order : in     Boolean := False;
                              Max   : in     Integer_4 := Integer_4'Last) is
      use Sql;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      if Order then
         Sql.Prepare (Stm_Select_Event_Date_O, " select * from DRY_MARKETS " &
                        " order by MARKET_ID "  ) ;

         Read_List (Stm_Select_Event_Date_O, List, Max);
      else
         Sql.Prepare (Stm_Select_Event_Date, " select * from DRY_MARKETS "  ) ;

         Read_List (Stm_Select_Event_Date, List, Max);
      end if;
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read_Event_Date;
   ---------------------------------------------
   procedure Read_One_Event_Date (Data       : in out Table_Dry_Markets.Data_Type;
                                  Order      : in     Boolean := False;
                                  End_Of_Set : in out Boolean) is
      List : Dry_Markets_List_Pack.List_Type := Dry_Markets_List_Pack.Create;
   begin
      Read_Event_Date (Data, List, Order, 1);
      if Dry_Markets_List_Pack.Is_Empty (List) then
         End_Of_Set := True;
      else
         End_Of_Set := False;
         Dry_Markets_List_Pack.Remove_From_Head (List, Data);
      end if;
      Dry_Markets_List_Pack.Release (List);
   end Read_One_Event_Date;
   ---------------------------------------------

   function Count_Event_Date (Data : Table_Dry_Markets.Data_Type) return Integer_4 is
      use Sql;
      Count       : Integer_4 := 0;
      End_Of_Set  : Boolean := False;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      Sql.Prepare (Stm_Select_Count_Event_Date, "select count('a') from DRY_MARKETS where EVENT_DATE = :EVENT_DATE ");

      Sql.Open_Cursor (Stm_Select_Count_Event_Date);
      Sql.Fetch (Stm_Select_Count_Event_Date, End_Of_Set);
      if not End_Of_Set then
         Sql.Get (Stm_Select_Count_Event_Date, 1, Count);
      end if;
      Sql.Close_Cursor (Stm_Select_Count_Event_Date);
      if Start_Trans then Sql.Commit (Transaction); end if;
      return Count;
   end Count_Event_Date;
   ---------------------------------------------
   procedure Delete_Event_Date (Data  : in     Table_Dry_Markets.Data_Type) is
   begin
      Sql.Prepare (Stm_Delete_Event_Date, " delete from DRY_MARKETS "  ) ;

      Sql.Execute (Stm_Delete_Event_Date);
   end Delete_Event_Date;
   ---------------------------------------------


   -- Index

   procedure Read_Event_Hierarchy (Data  : in     Table_Dry_Markets.Data_Type;
                                   List  : in out Dry_Markets_List_Pack.List_Type;
                                   Order : in     Boolean := False;
                                   Max   : in     Integer_4 := Integer_4'Last) is
      use Sql;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      if Order then
         Sql.Prepare (Stm_Select_Event_Hierarchy_O, " select * from DRY_MARKETS " &
                        " order by MARKET_ID "  ) ;

         Read_List (Stm_Select_Event_Hierarchy_O, List, Max);
      else
         Sql.Prepare (Stm_Select_Event_Hierarchy, " select * from DRY_MARKETS "  ) ;

         Read_List (Stm_Select_Event_Hierarchy, List, Max);
      end if;
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read_Event_Hierarchy;
   ---------------------------------------------
   procedure Read_One_Event_Hierarchy (Data       : in out Table_Dry_Markets.Data_Type;
                                       Order      : in     Boolean := False;
                                       End_Of_Set : in out Boolean) is
      List : Dry_Markets_List_Pack.List_Type := Dry_Markets_List_Pack.Create;
   begin
      Read_Event_Hierarchy (Data, List, Order, 1);
      if Dry_Markets_List_Pack.Is_Empty (List) then
         End_Of_Set := True;
      else
         End_Of_Set := False;
         Dry_Markets_List_Pack.Remove_From_Head (List, Data);
      end if;
      Dry_Markets_List_Pack.Release (List);
   end Read_One_Event_Hierarchy;
   ---------------------------------------------

   function Count_Event_Hierarchy (Data : Table_Dry_Markets.Data_Type) return Integer_4 is
      use Sql;
      Count       : Integer_4 := 0;
      End_Of_Set  : Boolean := False;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      Sql.Prepare (Stm_Select_Count_Event_Hierarchy, "select count('a') from DRY_MARKETS where EVENT_HIERARCHY = :EVENT_HIERARCHY ");

      Sql.Open_Cursor (Stm_Select_Count_Event_Hierarchy);
      Sql.Fetch (Stm_Select_Count_Event_Hierarchy, End_Of_Set);
      if not End_Of_Set then
         Sql.Get (Stm_Select_Count_Event_Hierarchy, 1, Count);
      end if;
      Sql.Close_Cursor (Stm_Select_Count_Event_Hierarchy);
      if Start_Trans then Sql.Commit (Transaction); end if;
      return Count;
   end Count_Event_Hierarchy;
   ---------------------------------------------
   procedure Delete_Event_Hierarchy (Data  : in     Table_Dry_Markets.Data_Type) is
   begin
      Sql.Prepare (Stm_Delete_Event_Hierarchy, " delete from DRY_MARKETS "  ) ;

      Sql.Execute (Stm_Delete_Event_Hierarchy);
   end Delete_Event_Hierarchy;
   ---------------------------------------------


   -- Index

   procedure Read_Market_Name (Data  : in     Table_Dry_Markets.Data_Type;
                               List  : in out Dry_Markets_List_Pack.List_Type;
                               Order : in     Boolean := False;
                               Max   : in     Integer_4 := Integer_4'Last) is
      use Sql;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      if Order then
         Sql.Prepare (Stm_Select_Market_Name_O, " select * from DRY_MARKETS " &
                        " order by MARKET_ID "  ) ;

         Read_List (Stm_Select_Market_Name_O, List, Max);
      else
         Sql.Prepare (Stm_Select_Market_Name, " select * from DRY_MARKETS "  ) ;

         Read_List (Stm_Select_Market_Name, List, Max);
      end if;
      if Start_Trans then Sql.Commit (Transaction); end if;
   end Read_Market_Name;
   ---------------------------------------------
   procedure Read_One_Market_Name (Data       : in out Table_Dry_Markets.Data_Type;
                                   Order      : in     Boolean := False;
                                   End_Of_Set : in out Boolean) is
      List : Dry_Markets_List_Pack.List_Type := Dry_Markets_List_Pack.Create;
   begin
      Read_Market_Name (Data, List, Order, 1);
      if Dry_Markets_List_Pack.Is_Empty (List) then
         End_Of_Set := True;
      else
         End_Of_Set := False;
         Dry_Markets_List_Pack.Remove_From_Head (List, Data);
      end if;
      Dry_Markets_List_Pack.Release (List);
   end Read_One_Market_Name;
   ---------------------------------------------

   function Count_Market_Name (Data : Table_Dry_Markets.Data_Type) return Integer_4 is
      use Sql;
      Count       : Integer_4 := 0;
      End_Of_Set  : Boolean := False;
      Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
      Transaction : Sql.Transaction_Type;
   begin
      if Start_Trans then Sql.Start_Read_Write_Transaction (Transaction); end if;
      Sql.Prepare (Stm_Select_Count_Market_Name, "select count('a') from DRY_MARKETS where MARKET_NAME = :MARKET_NAME ");

      Sql.Open_Cursor (Stm_Select_Count_Market_Name);
      Sql.Fetch (Stm_Select_Count_Market_Name, End_Of_Set);
      if not End_Of_Set then
         Sql.Get (Stm_Select_Count_Market_Name, 1, Count);
      end if;
      Sql.Close_Cursor (Stm_Select_Count_Market_Name);
      if Start_Trans then Sql.Commit (Transaction); end if;
      return Count;
   end Count_Market_Name;
   ---------------------------------------------
   procedure Delete_Market_Name (Data  : in     Table_Dry_Markets.Data_Type) is
   begin
      Sql.Prepare (Stm_Delete_Market_Name, " delete from DRY_MARKETS "  ) ;

      Sql.Execute (Stm_Delete_Market_Name);
   end Delete_Market_Name;
   ---------------------------------------------




   -- Procedures for all DBMS


   function Date_To_String (Date : in Sattmate_Calendar.Time_Type) return String is
      package Integer_2_Io is new Text_Io.Integer_Io (Integer_2);
      Date_String : String (1 .. 10) := "yyyy-mm-dd";
   begin
      Integer_2_Io.Put (Date_String (9 .. 10), Date.Day);
      Integer_2_Io.Put (Date_String (6 .. 7), Date.Month);
      Integer_2_Io.Put (Date_String (1 .. 4), Date.Year);
      if Date_String (9) = ' ' then Date_String (9) := '0'; end if;
      if Date_String (6) = ' ' then Date_String (6) := '0'; end if;
      return Date_String;
   end Date_To_String;
   --------------------------------------------



   function To_String (Data : in Table_Dry_Markets.Data_Type) return String is
   begin
      return
        " Market_id = " & Integer_4'Image (Data.Market_Id) &
        " Bsp_market = " & General_Routines.Skip_Trailing_Blanks (Data.Bsp_Market) &
        " Market_type = " & General_Routines.Skip_Trailing_Blanks (Data.Market_Type) &
        " Event_hierarchy = " & General_Routines.Skip_Trailing_Blanks (Data.Event_Hierarchy) &
        " Last_refresh = " & Sattmate_Calendar.String_Date_And_Time (Data.Last_Refresh, Milliseconds => True) &
        " Turning_in_play = " & General_Routines.Skip_Trailing_Blanks (Data.Turning_In_Play) &
        " Menu_path = " & General_Routines.Skip_Trailing_Blanks (Data.Menu_Path) &
        " Bet_delay = " & Integer_4'Image (Data.Bet_Delay) &
        " Exchange_id = " & Integer_4'Image (Data.Exchange_Id) &
        " Country_code = " & General_Routines.Skip_Trailing_Blanks (Data.Country_Code) &
        " Market_name = " & General_Routines.Skip_Trailing_Blanks (Data.Market_Name) &
        " Market_status = " & General_Routines.Skip_Trailing_Blanks (Data.Market_Status) &
        " Event_date = " & Sattmate_Calendar.String_Date_And_Time (Data.Event_Date, Milliseconds => True) &
        " No_of_runners = " & Integer_4'Image (Data.No_Of_Runners) &
        " Total_matched = " & Integer_4'Image (Data.Total_Matched) &
        " No_of_winners = " & Integer_4'Image (Data.No_Of_Winners) &
        "";
   end To_String;
   --------------------------------------------


end Table_Dry_Markets ;

