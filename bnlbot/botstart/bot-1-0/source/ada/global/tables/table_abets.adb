
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- /home/bnl/bnlbot/botstart/bot-1-0/script/tcl/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_io, General_Routines, Text_Io;
with Ada.Strings.Fixed;

package body Table_Abets is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  Stm_Delete_With_Check,
  Stm_Update_With_Check  : Sql.Statement_Type;


  -- Index 
  Stm_Select_Count_Marketid ,
  Stm_Select_Marketid ,
  Stm_Delete_Marketid ,
  Stm_Select_Marketid_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Betwon ,
  Stm_Select_Betwon ,
  Stm_Delete_Betwon ,
  Stm_Select_Betwon_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Powerdays ,
  Stm_Select_Powerdays ,
  Stm_Delete_Powerdays ,
  Stm_Select_Powerdays_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Betplaced ,
  Stm_Select_Betplaced ,
  Stm_Delete_Betplaced ,
  Stm_Select_Betplaced_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Startts ,
  Stm_Select_Startts ,
  Stm_Delete_Startts ,
  Stm_Select_Startts_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Betname ,
  Stm_Select_Betname ,
  Stm_Delete_Betname ,
  Stm_Select_Betname_O : Sql.Statement_Type;


  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_Abets.Data_Type is
    Data : Table_Abets.Data_Type;
  begin
    if not Sql.Is_Null(Stm, "BETID") then
      Sql.Get(Stm, "BETID", Data.Betid);
    else
      Data.Betid := 0;
    end if;
    if not Sql.Is_Null(Stm, "MARKETID") then
      Sql.Get(Stm, "MARKETID", Data.Marketid);
    else
      Data.Marketid := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "BETMODE") then
      Sql.Get(Stm, "BETMODE", Data.Betmode);
    else
      Data.Betmode := 0;
    end if;
    if not Sql.Is_Null(Stm, "POWERDAYS") then
      Sql.Get(Stm, "POWERDAYS", Data.Powerdays);
    else
      Data.Powerdays := 0;
    end if;
    if not Sql.Is_Null(Stm, "SELECTIONID") then
      Sql.Get(Stm, "SELECTIONID", Data.Selectionid);
    else
      Data.Selectionid := 0;
    end if;
    if not Sql.Is_Null(Stm, "REFERENCE") then
      Sql.Get(Stm, "REFERENCE", Data.Reference);
    else
      Data.Reference := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "SIZE") then
      Sql.Get(Stm, "SIZE", Data.Size);
    else
      Data.Size := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "PRICE") then
      Sql.Get(Stm, "PRICE", Data.Price);
    else
      Data.Price := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "SIDE") then
      Sql.Get(Stm, "SIDE", Data.Side);
    else
      Data.Side := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "BETNAME") then
      Sql.Get(Stm, "BETNAME", Data.Betname);
    else
      Data.Betname := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "BETWON") then
      Sql.Get(Stm, "BETWON", Data.Betwon);
    else
      Data.Betwon := False;
    end if;
    if not Sql.Is_Null(Stm, "PROFIT") then
      Sql.Get(Stm, "PROFIT", Data.Profit);
    else
      Data.Profit := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "STATUS") then
      Sql.Get(Stm, "STATUS", Data.Status);
    else
      Data.Status := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "EXESTATUS") then
      Sql.Get(Stm, "EXESTATUS", Data.Exestatus);
    else
      Data.Exestatus := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "EXEERRCODE") then
      Sql.Get(Stm, "EXEERRCODE", Data.Exeerrcode);
    else
      Data.Exeerrcode := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "INSTSTATUS") then
      Sql.Get(Stm, "INSTSTATUS", Data.Inststatus);
    else
      Data.Inststatus := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "INSTERRCODE") then
      Sql.Get(Stm, "INSTERRCODE", Data.Insterrcode);
    else
      Data.Insterrcode := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "STARTTS") then
      Sql.Get_Timestamp(Stm, "STARTTS", Data.Startts);
    else
      Data.Startts := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "BETPLACED") then
      Sql.Get_Timestamp(Stm, "BETPLACED", Data.Betplaced);
    else
      Data.Betplaced := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "PRICEMATCHED") then
      Sql.Get(Stm, "PRICEMATCHED", Data.Pricematched);
    else
      Data.Pricematched := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "SIZEMATCHED") then
      Sql.Get(Stm, "SIZEMATCHED", Data.Sizematched);
    else
      Data.Sizematched := 0.0;
    end if;
    if not Sql.Is_Null(Stm, "RUNNERNAME") then
      Sql.Get(Stm, "RUNNERNAME", Data.Runnername);
    else
      Data.Runnername := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "FULLMARKETNAME") then
      Sql.Get(Stm, "FULLMARKETNAME", Data.Fullmarketname);
    else
      Data.Fullmarketname := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "SVNREVISION") then
      Sql.Get(Stm, "SVNREVISION", Data.Svnrevision);
    else
      Data.Svnrevision := 0;
    end if;
    if not Sql.Is_Null(Stm, "IXXLUPD") then
      Sql.Get(Stm, "IXXLUPD", Data.Ixxlupd);
    else
      Data.Ixxlupd := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "IXXLUTS") then
      Sql.Get_Timestamp(Stm, "IXXLUTS", Data.Ixxluts);
    else
      Data.Ixxluts := Time_Type_First;
    end if;
  return Data;
  end Get;
---------------------------------------------

  function Get(Betid : Integer_8) return Table_Abets.Data_Type is
    Data       : Table_Abets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Betid := Betid;
    Read(Data, End_Of_Set);
    return Data;
  end Get;
--------------------------------------------

  procedure Read_All(List  : in out Abets_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_All_O, "select * from ABETS order by BETID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Sql.Prepare(Stm_Select_All, "select * from ABETS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_All;
--------------------------------------------


  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out Abets_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Count       : Integer_4 := 0;
    Data        : Table_Abets.Data_Type;
    Eos         : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Open_Cursor(Stm);
    loop
      Sql.Fetch(Stm, Eos); 
      exit when Eos or Count > Max;
      Data := Get(Stm);
      Abets_List_Pack.Insert_At_Tail(List, Data);
      Count := Count +1;
    end loop;
    Sql.Close_Cursor(Stm);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_List;
--------------------------------------------

  function Is_Existing(Betid : Integer_8) return Boolean is
    Data       : Table_Abets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Betid := Betid;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;
--------------------------------------------

  procedure Read(Data       : in out Table_Abets.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select, " select * from ABETS " & 
            "where BETID=:BETID" ) ;
    Sql.Set(Stm_Select, "BETID", Data.Betid);

    Sql.Open_Cursor(Stm_Select);
    Sql.Fetch(Stm_Select, End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Sql.Close_Cursor(Stm_Select);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read;
---------------------------------------------

  procedure Delete(Data : in Table_Abets.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete, " delete from ABETS " & 
            "where BETID=:BETID" ) ;
    Sql.Set(Stm_Delete, "BETID", Data.Betid);

    Sql.Execute(Stm_Delete);
  end Delete;
--------------------------------------------

  procedure Update(Data : in out Table_Abets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Sql.Prepare(Stm_Update, "update ABETS set " &
            "MARKETID=:MARKETID," &
            "BETMODE=:BETMODE," &
            "POWERDAYS=:POWERDAYS," &
            "SELECTIONID=:SELECTIONID," &
            "REFERENCE=:REFERENCE," &
            "SIZE=:SIZE," &
            "PRICE=:PRICE," &
            "SIDE=:SIDE," &
            "BETNAME=:BETNAME," &
            "BETWON=:BETWON," &
            "PROFIT=:PROFIT," &
            "STATUS=:STATUS," &
            "EXESTATUS=:EXESTATUS," &
            "EXEERRCODE=:EXEERRCODE," &
            "INSTSTATUS=:INSTSTATUS," &
            "INSTERRCODE=:INSTERRCODE," &
            "STARTTS=:STARTTS," &
            "BETPLACED=:BETPLACED," &
            "PRICEMATCHED=:PRICEMATCHED," &
            "SIZEMATCHED=:SIZEMATCHED," &
            "RUNNERNAME=:RUNNERNAME," &
            "FULLMARKETNAME=:FULLMARKETNAME," &
            "SVNREVISION=:SVNREVISION," &
            "IXXLUPD=:IXXLUPD," &
            "IXXLUTS=:IXXLUTS " &
            "where BETID=:BETID " ) ;
    Sql.Set(Stm_Update, "BETID",Data.Betid);
    Sql.Set(Stm_Update, "MARKETID",Data.Marketid);
    Sql.Set(Stm_Update, "BETMODE",Data.Betmode);
    Sql.Set(Stm_Update, "POWERDAYS",Data.Powerdays);
    Sql.Set(Stm_Update, "SELECTIONID",Data.Selectionid);
    Sql.Set(Stm_Update, "REFERENCE",Data.Reference);
    Sql.Set(Stm_Update, "SIZE",Data.Size);
    Sql.Set(Stm_Update, "PRICE",Data.Price);
    Sql.Set(Stm_Update, "SIDE",Data.Side);
    Sql.Set(Stm_Update, "BETNAME",Data.Betname);
    Sql.Set(Stm_Update, "BETWON",Data.Betwon);
    Sql.Set(Stm_Update, "PROFIT",Data.Profit);
    Sql.Set(Stm_Update, "STATUS",Data.Status);
    Sql.Set(Stm_Update, "EXESTATUS",Data.Exestatus);
    Sql.Set(Stm_Update, "EXEERRCODE",Data.Exeerrcode);
    Sql.Set(Stm_Update, "INSTSTATUS",Data.Inststatus);
    Sql.Set(Stm_Update, "INSTERRCODE",Data.Insterrcode);
    if Data.Startts = Time_Type_First then
      Sql.Set_Null_Date(Stm_Update, "STARTTS");
    else
      Sql.Set_Timestamp(Stm_Update, "STARTTS",Data.Startts);
    end if;
    if Data.Betplaced = Time_Type_First then
      Sql.Set_Null_Date(Stm_Update, "BETPLACED");
    else
      Sql.Set_Timestamp(Stm_Update, "BETPLACED",Data.Betplaced);
    end if;
    Sql.Set(Stm_Update, "PRICEMATCHED",Data.Pricematched);
    Sql.Set(Stm_Update, "SIZEMATCHED",Data.Sizematched);
    Sql.Set(Stm_Update, "RUNNERNAME",Data.Runnername);
    Sql.Set(Stm_Update, "FULLMARKETNAME",Data.Fullmarketname);
    Sql.Set(Stm_Update, "SVNREVISION",Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name;
    end if;
    Sql.Set(Stm_Update, "IXXLUPD",Data.Ixxlupd);
    Sql.Set_Timestamp(Stm_Update, "IXXLUTS",Data.Ixxluts);

    Sql.Execute(Stm_Update);
  end Update;
--------------------------------------------

  procedure Insert(Data : in out Table_Abets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      null; --for tables without IXX*
    Data.Ixxluts := Now;
    end if;
    Sql.Prepare(Stm_Insert, "insert into ABETS values (" &
            ":BETID, " &
            ":MARKETID, " &
            ":BETMODE, " &
            ":POWERDAYS, " &
            ":SELECTIONID, " &
            ":REFERENCE, " &
            ":SIZE, " &
            ":PRICE, " &
            ":SIDE, " &
            ":BETNAME, " &
            ":BETWON, " &
            ":PROFIT, " &
            ":STATUS, " &
            ":EXESTATUS, " &
            ":EXEERRCODE, " &
            ":INSTSTATUS, " &
            ":INSTERRCODE, " &
            ":STARTTS, " &
            ":BETPLACED, " &
            ":PRICEMATCHED, " &
            ":SIZEMATCHED, " &
            ":RUNNERNAME, " &
            ":FULLMARKETNAME, " &
            ":SVNREVISION, " &
            ":IXXLUPD, " &
            ":IXXLUTS) " ) ;
    Sql.Set(Stm_Insert, "BETID",Data.Betid);
    Sql.Set(Stm_Insert, "MARKETID",Data.Marketid);
    Sql.Set(Stm_Insert, "BETMODE",Data.Betmode);
    Sql.Set(Stm_Insert, "POWERDAYS",Data.Powerdays);
    Sql.Set(Stm_Insert, "SELECTIONID",Data.Selectionid);
    Sql.Set(Stm_Insert, "REFERENCE",Data.Reference);
    Sql.Set(Stm_Insert, "SIZE",Data.Size);
    Sql.Set(Stm_Insert, "PRICE",Data.Price);
    Sql.Set(Stm_Insert, "SIDE",Data.Side);
    Sql.Set(Stm_Insert, "BETNAME",Data.Betname);
    Sql.Set(Stm_Insert, "BETWON",Data.Betwon);
    Sql.Set(Stm_Insert, "PROFIT",Data.Profit);
    Sql.Set(Stm_Insert, "STATUS",Data.Status);
    Sql.Set(Stm_Insert, "EXESTATUS",Data.Exestatus);
    Sql.Set(Stm_Insert, "EXEERRCODE",Data.Exeerrcode);
    Sql.Set(Stm_Insert, "INSTSTATUS",Data.Inststatus);
    Sql.Set(Stm_Insert, "INSTERRCODE",Data.Insterrcode);
    if Data.Startts = Time_Type_First then
      Sql.Set_Null_Date(Stm_Insert, "STARTTS");
    else
      Sql.Set_Timestamp(Stm_Insert, "STARTTS",Data.Startts);
    end if;
    if Data.Betplaced = Time_Type_First then
      Sql.Set_Null_Date(Stm_Insert, "BETPLACED");
    else
      Sql.Set_Timestamp(Stm_Insert, "BETPLACED",Data.Betplaced);
    end if;
    Sql.Set(Stm_Insert, "PRICEMATCHED",Data.Pricematched);
    Sql.Set(Stm_Insert, "SIZEMATCHED",Data.Sizematched);
    Sql.Set(Stm_Insert, "RUNNERNAME",Data.Runnername);
    Sql.Set(Stm_Insert, "FULLMARKETNAME",Data.Fullmarketname);
    Sql.Set(Stm_Insert, "SVNREVISION",Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name;
    end if;
    Sql.Set(Stm_Insert, "IXXLUPD",Data.Ixxlupd);
    Sql.Set_Timestamp(Stm_Insert, "IXXLUTS",Data.Ixxluts);

    Sql.Execute(Stm_Insert);
  end Insert;
--------------------------------------------

  procedure Delete_Withcheck(Data : in Table_Abets.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete_With_Check, " delete from ABETS " & 
            "where BETID=:BETID" &
            " and IXXLUPD=:IXXLUPD" &
            " and IXXLUTS=:IXXLUTS" ) ;
    Sql.Set(Stm_Delete_With_Check, "BETID", Data.Betid);
    Sql.Set(Stm_Delete_With_Check, "IXXLUPD", Data.Ixxlupd);
    Sql.Set_Timestamp(Stm_Delete_With_Check, "IXXLUTS", Data.Ixxluts);

    Sql.Execute(Stm_Delete_With_Check);
  end Delete_Withcheck;
--------------------------------------------

  procedure Update_Withcheck(Data : in out Table_Abets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin

    Sql.Prepare(Stm_Update_With_Check, "update ABETS set " &
            "MARKETID=:MARKETID," &
            "BETMODE=:BETMODE," &
            "POWERDAYS=:POWERDAYS," &
            "SELECTIONID=:SELECTIONID," &
            "REFERENCE=:REFERENCE," &
            "SIZE=:SIZE," &
            "PRICE=:PRICE," &
            "SIDE=:SIDE," &
            "BETNAME=:BETNAME," &
            "BETWON=:BETWON," &
            "PROFIT=:PROFIT," &
            "STATUS=:STATUS," &
            "EXESTATUS=:EXESTATUS," &
            "EXEERRCODE=:EXEERRCODE," &
            "INSTSTATUS=:INSTSTATUS," &
            "INSTERRCODE=:INSTERRCODE," &
            "STARTTS=:STARTTS," &
            "BETPLACED=:BETPLACED," &
            "PRICEMATCHED=:PRICEMATCHED," &
            "SIZEMATCHED=:SIZEMATCHED," &
            "RUNNERNAME=:RUNNERNAME," &
            "FULLMARKETNAME=:FULLMARKETNAME," &
            "SVNREVISION=:SVNREVISION," &
            "IXXLUPD=:IXXLUPD," &
            "IXXLUTS=:IXXLUTS " &
            "where BETID=:BETID " &
            "and IXXLUPD=:OLD_IXXLUPD " &
            "and IXXLUTS=:OLD_IXXLUTS " ) ;
    Sql.Set(Stm_Update_With_Check, "OLD_IXXLUPD",Data.Ixxlupd);
    Sql.Set_Timestamp(Stm_Update_With_Check, "OLD_IXXLUTS",Data.Ixxluts);
    if not Keep_Timestamp then
      null; --for tables without Ixx* 
      Data.Ixxluts := Now;
    end if;
    Sql.Set(Stm_Update_With_Check, "BETID",Data.Betid);
    Sql.Set(Stm_Update_With_Check, "MARKETID",Data.Marketid);
    Sql.Set(Stm_Update_With_Check, "BETMODE",Data.Betmode);
    Sql.Set(Stm_Update_With_Check, "POWERDAYS",Data.Powerdays);
    Sql.Set(Stm_Update_With_Check, "SELECTIONID",Data.Selectionid);
    Sql.Set(Stm_Update_With_Check, "REFERENCE",Data.Reference);
    Sql.Set(Stm_Update_With_Check, "SIZE",Data.Size);
    Sql.Set(Stm_Update_With_Check, "PRICE",Data.Price);
    Sql.Set(Stm_Update_With_Check, "SIDE",Data.Side);
    Sql.Set(Stm_Update_With_Check, "BETNAME",Data.Betname);
    Sql.Set(Stm_Update_With_Check, "BETWON",Data.Betwon);
    Sql.Set(Stm_Update_With_Check, "PROFIT",Data.Profit);
    Sql.Set(Stm_Update_With_Check, "STATUS",Data.Status);
    Sql.Set(Stm_Update_With_Check, "EXESTATUS",Data.Exestatus);
    Sql.Set(Stm_Update_With_Check, "EXEERRCODE",Data.Exeerrcode);
    Sql.Set(Stm_Update_With_Check, "INSTSTATUS",Data.Inststatus);
    Sql.Set(Stm_Update_With_Check, "INSTERRCODE",Data.Insterrcode);
    if Data.Startts = Time_Type_First then
      Sql.Set_Null_Date(Stm_Update_With_Check, "STARTTS");
    else
      Sql.Set_Timestamp(Stm_Update_With_Check, "STARTTS",Data.Startts);
    end if;
    if Data.Betplaced = Time_Type_First then
      Sql.Set_Null_Date(Stm_Update_With_Check, "BETPLACED");
    else
      Sql.Set_Timestamp(Stm_Update_With_Check, "BETPLACED",Data.Betplaced);
    end if;
    Sql.Set(Stm_Update_With_Check, "PRICEMATCHED",Data.Pricematched);
    Sql.Set(Stm_Update_With_Check, "SIZEMATCHED",Data.Sizematched);
    Sql.Set(Stm_Update_With_Check, "RUNNERNAME",Data.Runnername);
    Sql.Set(Stm_Update_With_Check, "FULLMARKETNAME",Data.Fullmarketname);
    Sql.Set(Stm_Update_With_Check, "SVNREVISION",Data.Svnrevision);
    if not Keep_Timestamp then
      null; --for tables without Ixxlupd
      Data.Ixxlupd := Process.Name;
    end if;
    Sql.Set(Stm_Update_With_Check, "IXXLUPD",Data.Ixxlupd);
    Sql.Set_Timestamp(Stm_Update_With_Check, "IXXLUTS",Data.Ixxluts);

    Sql.Execute(Stm_Update_With_Check);
  end Update_Withcheck;
--------------------------------------------

  -- Primary key, when several fields

  -- Index 

  procedure Read_Marketid(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Marketid_O, " select * from ABETS " & 
            "where MARKETID=:MARKETID" &
            " order by BETID "  ) ; 
      Sql.Set(Stm_Select_Marketid_O, "MARKETID", Data.Marketid);
 
      Read_List(Stm_Select_Marketid_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Marketid, " select * from ABETS " & 
            "where MARKETID=:MARKETID"  ) ; 
      Sql.Set(Stm_Select_Marketid, "MARKETID", Data.Marketid);
 
      Read_List(Stm_Select_Marketid, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Marketid;
---------------------------------------------
  procedure Read_One_Marketid(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Marketid(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Marketid;
---------------------------------------------

  function Count_Marketid(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Marketid, "select count('a') from ABETS where MARKETID = :MARKETID ");
    Sql.Set(Stm_Select_Count_Marketid, "MARKETID", Data.Marketid);
 
    Sql.Open_Cursor(Stm_Select_Count_Marketid);
    Sql.Fetch(Stm_Select_Count_Marketid, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Marketid, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Marketid);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Marketid;
---------------------------------------------
  procedure Delete_Marketid(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Marketid, " delete from ABETS " & 
            "where MARKETID=:MARKETID"  ) ; 
      Sql.Set(Stm_Delete_Marketid, "MARKETID", Data.Marketid);
 
    Sql.Execute(Stm_Delete_Marketid);
  end Delete_Marketid;
---------------------------------------------


  -- Index 

  procedure Read_Betwon(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Betwon_O, " select * from ABETS " & 
            "where BETWON=:BETWON" &
            " order by BETID "  ) ; 
      Sql.Set(Stm_Select_Betwon_O, "BETWON", Data.Betwon);
 
      Read_List(Stm_Select_Betwon_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Betwon, " select * from ABETS " & 
            "where BETWON=:BETWON"  ) ; 
      Sql.Set(Stm_Select_Betwon, "BETWON", Data.Betwon);
 
      Read_List(Stm_Select_Betwon, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Betwon;
---------------------------------------------
  procedure Read_One_Betwon(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Betwon(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Betwon;
---------------------------------------------

  function Count_Betwon(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Betwon, "select count('a') from ABETS where BETWON = :BETWON ");
    Sql.Set(Stm_Select_Count_Betwon, "BETWON", Data.Betwon);
 
    Sql.Open_Cursor(Stm_Select_Count_Betwon);
    Sql.Fetch(Stm_Select_Count_Betwon, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Betwon, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Betwon);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Betwon;
---------------------------------------------
  procedure Delete_Betwon(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Betwon, " delete from ABETS " & 
            "where BETWON=:BETWON"  ) ; 
      Sql.Set(Stm_Delete_Betwon, "BETWON", Data.Betwon);
 
    Sql.Execute(Stm_Delete_Betwon);
  end Delete_Betwon;
---------------------------------------------


  -- Index 

  procedure Read_Powerdays(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Powerdays_O, " select * from ABETS " & 
            "where POWERDAYS=:POWERDAYS" &
            " order by BETID "  ) ; 
      Sql.Set(Stm_Select_Powerdays_O, "POWERDAYS", Data.Powerdays);
 
      Read_List(Stm_Select_Powerdays_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Powerdays, " select * from ABETS " & 
            "where POWERDAYS=:POWERDAYS"  ) ; 
      Sql.Set(Stm_Select_Powerdays, "POWERDAYS", Data.Powerdays);
 
      Read_List(Stm_Select_Powerdays, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Powerdays;
---------------------------------------------
  procedure Read_One_Powerdays(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Powerdays(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Powerdays;
---------------------------------------------

  function Count_Powerdays(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Powerdays, "select count('a') from ABETS where POWERDAYS = :POWERDAYS ");
    Sql.Set(Stm_Select_Count_Powerdays, "POWERDAYS", Data.Powerdays);
 
    Sql.Open_Cursor(Stm_Select_Count_Powerdays);
    Sql.Fetch(Stm_Select_Count_Powerdays, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Powerdays, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Powerdays);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Powerdays;
---------------------------------------------
  procedure Delete_Powerdays(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Powerdays, " delete from ABETS " & 
            "where POWERDAYS=:POWERDAYS"  ) ; 
      Sql.Set(Stm_Delete_Powerdays, "POWERDAYS", Data.Powerdays);
 
    Sql.Execute(Stm_Delete_Powerdays);
  end Delete_Powerdays;
---------------------------------------------


  -- Index 

  procedure Read_Betplaced(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Betplaced_O, " select * from ABETS " & 
            "where BETPLACED=:BETPLACED" &
            " order by BETID "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Betplaced_O,"BETPLACED", Data.Betplaced);
 
      Read_List(Stm_Select_Betplaced_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Betplaced, " select * from ABETS " & 
            "where BETPLACED=:BETPLACED"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Betplaced,"BETPLACED", Data.Betplaced);
 
      Read_List(Stm_Select_Betplaced, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Betplaced;
---------------------------------------------
  procedure Read_One_Betplaced(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Betplaced(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Betplaced;
---------------------------------------------

  function Count_Betplaced(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Betplaced, "select count('a') from ABETS where BETPLACED = :BETPLACED ");
    Sql.Set_Timestamp(Stm_Select_Count_Betplaced,"BETPLACED", Data.Betplaced);
 
    Sql.Open_Cursor(Stm_Select_Count_Betplaced);
    Sql.Fetch(Stm_Select_Count_Betplaced, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Betplaced, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Betplaced);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Betplaced;
---------------------------------------------
  procedure Delete_Betplaced(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Betplaced, " delete from ABETS " & 
            "where BETPLACED=:BETPLACED"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Betplaced,"BETPLACED", Data.Betplaced);
 
    Sql.Execute(Stm_Delete_Betplaced);
  end Delete_Betplaced;
---------------------------------------------


  -- Index 

  procedure Read_Startts(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Startts_O, " select * from ABETS " & 
            "where STARTTS=:STARTTS" &
            " order by BETID "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Startts_O,"STARTTS", Data.Startts);
 
      Read_List(Stm_Select_Startts_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Startts, " select * from ABETS " & 
            "where STARTTS=:STARTTS"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Startts,"STARTTS", Data.Startts);
 
      Read_List(Stm_Select_Startts, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Startts;
---------------------------------------------
  procedure Read_One_Startts(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Startts(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Startts;
---------------------------------------------

  function Count_Startts(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Startts, "select count('a') from ABETS where STARTTS = :STARTTS ");
    Sql.Set_Timestamp(Stm_Select_Count_Startts,"STARTTS", Data.Startts);
 
    Sql.Open_Cursor(Stm_Select_Count_Startts);
    Sql.Fetch(Stm_Select_Count_Startts, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Startts, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Startts);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Startts;
---------------------------------------------
  procedure Delete_Startts(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Startts, " delete from ABETS " & 
            "where STARTTS=:STARTTS"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Startts,"STARTTS", Data.Startts);
 
    Sql.Execute(Stm_Delete_Startts);
  end Delete_Startts;
---------------------------------------------


  -- Index 

  procedure Read_Betname(Data  : in     Table_Abets.Data_Type;
                       List  : in out Abets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Betname_O, " select * from ABETS " & 
            "where BETNAME=:BETNAME" &
            " order by BETID "  ) ; 
      Sql.Set(Stm_Select_Betname_O, "BETNAME", Data.Betname);
 
      Read_List(Stm_Select_Betname_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Betname, " select * from ABETS " & 
            "where BETNAME=:BETNAME"  ) ; 
      Sql.Set(Stm_Select_Betname, "BETNAME", Data.Betname);
 
      Read_List(Stm_Select_Betname, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Betname;
---------------------------------------------
  procedure Read_One_Betname(Data       : in out Table_Abets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Abets_List_Pack.List_Type := Abets_List_Pack.Create;
  begin
    Read_Betname(Data, List, Order, 1);
    if Abets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Abets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Abets_List_Pack.Release(List);
    end Read_One_Betname;
---------------------------------------------

  function Count_Betname(Data : Table_Abets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Betname, "select count('a') from ABETS where BETNAME = :BETNAME ");
    Sql.Set(Stm_Select_Count_Betname, "BETNAME", Data.Betname);
 
    Sql.Open_Cursor(Stm_Select_Count_Betname);
    Sql.Fetch(Stm_Select_Count_Betname, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Betname, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Betname);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Betname;
---------------------------------------------
  procedure Delete_Betname(Data  : in     Table_Abets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Betname, " delete from ABETS " & 
            "where BETNAME=:BETNAME"  ) ; 
      Sql.Set(Stm_Delete_Betname, "BETNAME", Data.Betname);
 
    Sql.Execute(Stm_Delete_Betname);
  end Delete_Betname;
---------------------------------------------



  -- Procedures for all DBMS


  function Date_To_String(Date : in Sattmate_Calendar.Time_Type) return String is
    package Integer_2_Io is new Text_Io.Integer_Io(Integer_2);
    Date_String : String(1..10) := "yyyy-mm-dd";
  begin
    Integer_2_Io.Put(Date_String(9..10), Date.Day);
    Integer_2_Io.Put(Date_String(6..7), Date.Month);
    Integer_2_Io.Put(Date_String(1..4), Date.Year);
    if Date_String(9) = ' ' then Date_String(9) := '0'; end if;
    if Date_String(6) = ' ' then Date_String(6) := '0'; end if;
    return Date_String;
  end Date_To_String;
--------------------------------------------



  function To_String(Data : in Table_Abets.Data_Type) return String is
  begin
    return
          " Betid = " & Integer_8'Image(Data.Betid) &
          " Marketid = " & General_Routines.Skip_Trailing_Blanks(Data.Marketid) &
          " Betmode = " & Integer_4'Image(Data.Betmode) &
          " Powerdays = " & Integer_4'Image(Data.Powerdays) &
          " Selectionid = " & Integer_4'Image(Data.Selectionid) &
          " Reference = " & General_Routines.Skip_Trailing_Blanks(Data.Reference) &
          " Size = " &  General_Routines.F8_Image(Data.Size) &
          " Price = " &  General_Routines.F8_Image(Data.Price) &
          " Side = " & General_Routines.Skip_Trailing_Blanks(Data.Side) &
          " Betname = " & General_Routines.Skip_Trailing_Blanks(Data.Betname) &
          " Betwon = " & Boolean'Image(Data.Betwon) &
          " Profit = " &  General_Routines.F8_Image(Data.Profit) &
          " Status = " & General_Routines.Skip_Trailing_Blanks(Data.Status) &
          " Exestatus = " & General_Routines.Skip_Trailing_Blanks(Data.Exestatus) &
          " Exeerrcode = " & General_Routines.Skip_Trailing_Blanks(Data.Exeerrcode) &
          " Inststatus = " & General_Routines.Skip_Trailing_Blanks(Data.Inststatus) &
          " Insterrcode = " & General_Routines.Skip_Trailing_Blanks(Data.Insterrcode) &
          " Startts = " & Sattmate_Calendar.String_Date_And_Time(Data.Startts, Milliseconds => true) &
          " Betplaced = " & Sattmate_Calendar.String_Date_And_Time(Data.Betplaced, Milliseconds => true) &
          " Pricematched = " &  General_Routines.F8_Image(Data.Pricematched) &
          " Sizematched = " &  General_Routines.F8_Image(Data.Sizematched) &
          " Runnername = " & General_Routines.Skip_Trailing_Blanks(Data.Runnername) &
          " Fullmarketname = " & General_Routines.Skip_Trailing_Blanks(Data.Fullmarketname) &
          " Svnrevision = " & Integer_4'Image(Data.Svnrevision) &
          " Ixxlupd = " & General_Routines.Skip_Trailing_Blanks(Data.Ixxlupd) &
          " Ixxluts = " & Sattmate_Calendar.String_Date_And_Time(Data.Ixxluts, Milliseconds => true) &
          "";
  end To_String;
--------------------------------------------

end Table_Abets ;

