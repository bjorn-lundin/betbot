
-----------------------------------------------------
-- This file is AUTOGENERATED by                     
-- /home/bnl/bnlbot/botstart/bot-1-0/script/tcl/make_table_package.tcl at                                       
--9.6-10510                                          
----CHANGES HERE WILL BE LOST NEXT GENERATE!!!!----- 
-----------DO NOT EDIT THIS FILE!!!!---------------- 
-----------------------------------------------------




pragma Warnings(Off);
with Process_io, General_Routines, Text_Io;
with Ada.Strings.Fixed;

package body Table_Drymarkets is

  Stm_Select,
  Stm_Delete,
  Stm_Update,
  Stm_Insert,
  Stm_Select_All,
  Stm_Select_All_O  : Sql.Statement_Type;


  -- Index 
  Stm_Select_Count_Eventdate ,
  Stm_Select_Eventdate ,
  Stm_Delete_Eventdate ,
  Stm_Select_Eventdate_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Eventhierarchy ,
  Stm_Select_Eventhierarchy ,
  Stm_Delete_Eventhierarchy ,
  Stm_Select_Eventhierarchy_O : Sql.Statement_Type;

  -- Index 
  Stm_Select_Count_Marketname ,
  Stm_Select_Marketname ,
  Stm_Delete_Marketname ,
  Stm_Select_Marketname_O : Sql.Statement_Type;


  -- Procedures for DBMS DEF
  -- Primary key
  function Get(Stm : in Sql.Statement_Type) return Table_Drymarkets.Data_Type is
    Data : Table_Drymarkets.Data_Type;
  begin
    if not Sql.Is_Null(Stm, "MARKETID") then
      Sql.Get(Stm, "MARKETID", Data.Marketid);
    else
      Data.Marketid := 0;
    end if;
    if not Sql.Is_Null(Stm, "BSPMARKET") then
      Sql.Get(Stm, "BSPMARKET", Data.Bspmarket);
    else
      Data.Bspmarket := ' ';
    end if;
    if not Sql.Is_Null(Stm, "MARKETTYPE") then
      Sql.Get(Stm, "MARKETTYPE", Data.Markettype);
    else
      Data.Markettype := ' ';
    end if;
    if not Sql.Is_Null(Stm, "EVENTHIERARCHY") then
      Sql.Get(Stm, "EVENTHIERARCHY", Data.Eventhierarchy);
    else
      Data.Eventhierarchy := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "LASTREFRESH") then
      Sql.Get_Timestamp(Stm, "LASTREFRESH", Data.Lastrefresh);
    else
      Data.Lastrefresh := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "TURNINGINPLAY") then
      Sql.Get(Stm, "TURNINGINPLAY", Data.Turninginplay);
    else
      Data.Turninginplay := ' ';
    end if;
    if not Sql.Is_Null(Stm, "MENUPATH") then
      Sql.Get(Stm, "MENUPATH", Data.Menupath);
    else
      Data.Menupath := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "BETDELAY") then
      Sql.Get(Stm, "BETDELAY", Data.Betdelay);
    else
      Data.Betdelay := 0;
    end if;
    if not Sql.Is_Null(Stm, "EXCHANGEID") then
      Sql.Get(Stm, "EXCHANGEID", Data.Exchangeid);
    else
      Data.Exchangeid := 0;
    end if;
    if not Sql.Is_Null(Stm, "COUNTRYCODE") then
      Sql.Get(Stm, "COUNTRYCODE", Data.Countrycode);
    else
      Data.Countrycode := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "MARKETNAME") then
      Sql.Get(Stm, "MARKETNAME", Data.Marketname);
    else
      Data.Marketname := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "MARKETSTATUS") then
      Sql.Get(Stm, "MARKETSTATUS", Data.Marketstatus);
    else
      Data.Marketstatus := (others => ' ');
    end if;
    if not Sql.Is_Null(Stm, "EVENTDATE") then
      Sql.Get_Timestamp(Stm, "EVENTDATE", Data.Eventdate);
    else
      Data.Eventdate := Time_Type_First;
    end if;
    if not Sql.Is_Null(Stm, "NOOFRUNNERS") then
      Sql.Get(Stm, "NOOFRUNNERS", Data.Noofrunners);
    else
      Data.Noofrunners := 0;
    end if;
    if not Sql.Is_Null(Stm, "TOTALMATCHED") then
      Sql.Get(Stm, "TOTALMATCHED", Data.Totalmatched);
    else
      Data.Totalmatched := 0;
    end if;
    if not Sql.Is_Null(Stm, "NOOFWINNERS") then
      Sql.Get(Stm, "NOOFWINNERS", Data.Noofwinners);
    else
      Data.Noofwinners := 0;
    end if;
  return Data;
  end Get;
---------------------------------------------

  function Get(Marketid : Integer_4) return Table_Drymarkets.Data_Type is
    Data       : Table_Drymarkets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Marketid := Marketid;
    Read(Data, End_Of_Set);
    return Data;
  end Get;
--------------------------------------------

  procedure Read_All(List  : in out Drymarkets_List_Pack.List_Type;
                     Order : in     Boolean := False;
                     Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_All_O, "select * from DRYMARKETS order by MARKETID");
      Read_List(Stm_Select_All_O, List, Max);
    else
      Sql.Prepare(Stm_Select_All, "select * from DRYMARKETS");
      Read_List(Stm_Select_All, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_All;
--------------------------------------------


  procedure Read_List(Stm  : in     Sql.Statement_Type;
                      List : in out Drymarkets_List_Pack.List_Type;
                      Max  : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Count       : Integer_4 := 0;
    Data        : Table_Drymarkets.Data_Type;
    Eos         : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction  : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Open_Cursor(Stm);
    loop
      Sql.Fetch(Stm, Eos); 
      exit when Eos or Count > Max;
      Data := Get(Stm);
      Drymarkets_List_Pack.Insert_At_Tail(List, Data);
      Count := Count +1;
    end loop;
    Sql.Close_Cursor(Stm);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_List;
--------------------------------------------

  function Is_Existing(Marketid : Integer_4) return Boolean is
    Data       : Table_Drymarkets.Data_Type;
    End_Of_Set : Boolean := True;
  begin
    Data.Marketid := Marketid;
    Read(Data, End_Of_Set);
    return not End_Of_Set;
  end Is_Existing;
--------------------------------------------

  procedure Read(Data       : in out Table_Drymarkets.Data_Type;
                 End_Of_Set : in out Boolean) is
    use Sql;
    Start_Trans   : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction   : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select, " select * from DRYMARKETS " & 
            "where MARKETID=:MARKETID" ) ;
    Sql.Set(Stm_Select, "MARKETID", Data.Marketid);

    Sql.Open_Cursor(Stm_Select);
    Sql.Fetch(Stm_Select, End_Of_Set);
    if not End_Of_Set then
      Data := Get(Stm_Select);
    end if;
    Sql.Close_Cursor(Stm_Select);
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read;
---------------------------------------------

  procedure Delete(Data : in Table_Drymarkets.Data_Type) is
  begin
    Sql.Prepare(Stm_Delete, " delete from DRYMARKETS " & 
            "where MARKETID=:MARKETID" ) ;
    Sql.Set(Stm_Delete, "MARKETID", Data.Marketid);

    Sql.Execute(Stm_Delete);
  end Delete;
--------------------------------------------

  procedure Update(Data : in out Table_Drymarkets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    Sql.Prepare(Stm_Update, "update DRYMARKETS set " &
            "BSPMARKET=:BSPMARKET," &
            "MARKETTYPE=:MARKETTYPE," &
            "EVENTHIERARCHY=:EVENTHIERARCHY," &
            "LASTREFRESH=:LASTREFRESH," &
            "TURNINGINPLAY=:TURNINGINPLAY," &
            "MENUPATH=:MENUPATH," &
            "BETDELAY=:BETDELAY," &
            "EXCHANGEID=:EXCHANGEID," &
            "COUNTRYCODE=:COUNTRYCODE," &
            "MARKETNAME=:MARKETNAME," &
            "MARKETSTATUS=:MARKETSTATUS," &
            "EVENTDATE=:EVENTDATE," &
            "NOOFRUNNERS=:NOOFRUNNERS," &
            "TOTALMATCHED=:TOTALMATCHED," &
            "NOOFWINNERS=:NOOFWINNERS " &
            "where MARKETID=:MARKETID " ) ;
    Sql.Set(Stm_Update, "MARKETID",Data.Marketid);
    Sql.Set(Stm_Update, "BSPMARKET",Data.Bspmarket);
    if Data.Markettype = ' ' then
      Sql.Set_Null(Stm_Update, "MARKETTYPE");
    else
      Sql.Set(Stm_Update, "MARKETTYPE",Data.Markettype);
    end if;
    Sql.Set(Stm_Update, "EVENTHIERARCHY",Data.Eventhierarchy);
    Sql.Set_Timestamp(Stm_Update, "LASTREFRESH",Data.Lastrefresh);
    Sql.Set(Stm_Update, "TURNINGINPLAY",Data.Turninginplay);
    if Data.Menupath = (Data.Menupath'Range => ' ') then
      Sql.Set_Null(Stm_Update, "MENUPATH");
    else
      Sql.Set(Stm_Update, "MENUPATH",Data.Menupath);
    end if;
    Sql.Set(Stm_Update, "BETDELAY",Data.Betdelay);
    Sql.Set(Stm_Update, "EXCHANGEID",Data.Exchangeid);
    Sql.Set(Stm_Update, "COUNTRYCODE",Data.Countrycode);
    if Data.Marketname = (Data.Marketname'Range => ' ') then
      Sql.Set_Null(Stm_Update, "MARKETNAME");
    else
      Sql.Set(Stm_Update, "MARKETNAME",Data.Marketname);
    end if;
    if Data.Marketstatus = (Data.Marketstatus'Range => ' ') then
      Sql.Set_Null(Stm_Update, "MARKETSTATUS");
    else
      Sql.Set(Stm_Update, "MARKETSTATUS",Data.Marketstatus);
    end if;
    if Data.Eventdate = Time_Type_First then
      Sql.Set_Null_Date(Stm_Update, "EVENTDATE");
    else
      Sql.Set_Timestamp(Stm_Update, "EVENTDATE",Data.Eventdate);
    end if;
    if Data.Noofrunners = 0 then
      Sql.Set_Null(Stm_Update, "NOOFRUNNERS");
    else
      Sql.Set(Stm_Update, "NOOFRUNNERS",Data.Noofrunners);
    end if;
    if Data.Totalmatched = 0 then
      Sql.Set_Null(Stm_Update, "TOTALMATCHED");
    else
      Sql.Set(Stm_Update, "TOTALMATCHED",Data.Totalmatched);
    end if;
    if Data.Noofwinners = 0 then
      Sql.Set_Null(Stm_Update, "NOOFWINNERS");
    else
      Sql.Set(Stm_Update, "NOOFWINNERS",Data.Noofwinners);
    end if;

    Sql.Execute(Stm_Update);
  end Update;
--------------------------------------------

  procedure Insert(Data : in out Table_Drymarkets.Data_Type; Keep_Timestamp : in Boolean := False) is
    Now     : Sattmate_Calendar.Time_Type := Sattmate_Calendar.Clock;
    Process : Process_Io.Process_Type     := Process_Io.This_Process;
  begin
    if not Keep_Timestamp then
      null; --for tables without IXX*
    end if;
    Sql.Prepare(Stm_Insert, "insert into DRYMARKETS values (" &
            ":MARKETID, " &
            ":BSPMARKET, " &
            ":MARKETTYPE, " &
            ":EVENTHIERARCHY, " &
            ":LASTREFRESH, " &
            ":TURNINGINPLAY, " &
            ":MENUPATH, " &
            ":BETDELAY, " &
            ":EXCHANGEID, " &
            ":COUNTRYCODE, " &
            ":MARKETNAME, " &
            ":MARKETSTATUS, " &
            ":EVENTDATE, " &
            ":NOOFRUNNERS, " &
            ":TOTALMATCHED, " &
            ":NOOFWINNERS) " ) ;
    Sql.Set(Stm_Insert, "MARKETID",Data.Marketid);
    Sql.Set(Stm_Insert, "BSPMARKET",Data.Bspmarket);
    if Data.Markettype = ' ' then
      Sql.Set_Null(Stm_Insert, "MARKETTYPE");
    else
      Sql.Set(Stm_Insert, "MARKETTYPE",Data.Markettype);
    end if;
    Sql.Set(Stm_Insert, "EVENTHIERARCHY",Data.Eventhierarchy);
    Sql.Set_Timestamp(Stm_Insert, "LASTREFRESH",Data.Lastrefresh);
    Sql.Set(Stm_Insert, "TURNINGINPLAY",Data.Turninginplay);
    if Data.Menupath = (Data.Menupath'Range => ' ') then
      Sql.Set_Null(Stm_Insert, "MENUPATH");
    else
      Sql.Set(Stm_Insert, "MENUPATH",Data.Menupath);
    end if;
    Sql.Set(Stm_Insert, "BETDELAY",Data.Betdelay);
    Sql.Set(Stm_Insert, "EXCHANGEID",Data.Exchangeid);
    Sql.Set(Stm_Insert, "COUNTRYCODE",Data.Countrycode);
    if Data.Marketname = (Data.Marketname'Range => ' ') then
      Sql.Set_Null(Stm_Insert, "MARKETNAME");
    else
      Sql.Set(Stm_Insert, "MARKETNAME",Data.Marketname);
    end if;
    if Data.Marketstatus = (Data.Marketstatus'Range => ' ') then
      Sql.Set_Null(Stm_Insert, "MARKETSTATUS");
    else
      Sql.Set(Stm_Insert, "MARKETSTATUS",Data.Marketstatus);
    end if;
    if Data.Eventdate = Time_Type_First then
      Sql.Set_Null_Date(Stm_Insert, "EVENTDATE");
    else
      Sql.Set_Timestamp(Stm_Insert, "EVENTDATE",Data.Eventdate);
    end if;
    if Data.Noofrunners = 0 then
      Sql.Set_Null(Stm_Insert, "NOOFRUNNERS");
    else
      Sql.Set(Stm_Insert, "NOOFRUNNERS",Data.Noofrunners);
    end if;
    if Data.Totalmatched = 0 then
      Sql.Set_Null(Stm_Insert, "TOTALMATCHED");
    else
      Sql.Set(Stm_Insert, "TOTALMATCHED",Data.Totalmatched);
    end if;
    if Data.Noofwinners = 0 then
      Sql.Set_Null(Stm_Insert, "NOOFWINNERS");
    else
      Sql.Set(Stm_Insert, "NOOFWINNERS",Data.Noofwinners);
    end if;

    Sql.Execute(Stm_Insert);
  end Insert;
--------------------------------------------

  -- Primary key, when several fields

  -- Index 

  procedure Read_Eventdate(Data  : in     Table_Drymarkets.Data_Type;
                       List  : in out Drymarkets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventdate_O, " select * from DRYMARKETS " & 
            "where EVENTDATE=:EVENTDATE" &
            " order by MARKETID "  ) ; 
      Sql.Set_Timestamp(Stm_Select_Eventdate_O,"EVENTDATE", Data.Eventdate);
 
      Read_List(Stm_Select_Eventdate_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventdate, " select * from DRYMARKETS " & 
            "where EVENTDATE=:EVENTDATE"  ) ; 
      Sql.Set_Timestamp(Stm_Select_Eventdate,"EVENTDATE", Data.Eventdate);
 
      Read_List(Stm_Select_Eventdate, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventdate;
---------------------------------------------
  procedure Read_One_Eventdate(Data       : in out Table_Drymarkets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Drymarkets_List_Pack.List_Type := Drymarkets_List_Pack.Create;
  begin
    Read_Eventdate(Data, List, Order, 1);
    if Drymarkets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Drymarkets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Drymarkets_List_Pack.Release(List);
    end Read_One_Eventdate;
---------------------------------------------

  function Count_Eventdate(Data : Table_Drymarkets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventdate, "select count('a') from DRYMARKETS where EVENTDATE = :EVENTDATE ");
    Sql.Set_Timestamp(Stm_Select_Count_Eventdate,"EVENTDATE", Data.Eventdate);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventdate);
    Sql.Fetch(Stm_Select_Count_Eventdate, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventdate, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventdate);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventdate;
---------------------------------------------
  procedure Delete_Eventdate(Data  : in     Table_Drymarkets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventdate, " delete from DRYMARKETS " & 
            "where EVENTDATE=:EVENTDATE"  ) ; 
      Sql.Set_Timestamp(Stm_Delete_Eventdate,"EVENTDATE", Data.Eventdate);
 
    Sql.Execute(Stm_Delete_Eventdate);
  end Delete_Eventdate;
---------------------------------------------


  -- Index 

  procedure Read_Eventhierarchy(Data  : in     Table_Drymarkets.Data_Type;
                       List  : in out Drymarkets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Eventhierarchy_O, " select * from DRYMARKETS " & 
            "where EVENTHIERARCHY=:EVENTHIERARCHY" &
            " order by MARKETID "  ) ; 
      Sql.Set(Stm_Select_Eventhierarchy_O, "EVENTHIERARCHY", Data.Eventhierarchy);
 
      Read_List(Stm_Select_Eventhierarchy_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Eventhierarchy, " select * from DRYMARKETS " & 
            "where EVENTHIERARCHY=:EVENTHIERARCHY"  ) ; 
      Sql.Set(Stm_Select_Eventhierarchy, "EVENTHIERARCHY", Data.Eventhierarchy);
 
      Read_List(Stm_Select_Eventhierarchy, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Eventhierarchy;
---------------------------------------------
  procedure Read_One_Eventhierarchy(Data       : in out Table_Drymarkets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Drymarkets_List_Pack.List_Type := Drymarkets_List_Pack.Create;
  begin
    Read_Eventhierarchy(Data, List, Order, 1);
    if Drymarkets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Drymarkets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Drymarkets_List_Pack.Release(List);
    end Read_One_Eventhierarchy;
---------------------------------------------

  function Count_Eventhierarchy(Data : Table_Drymarkets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Eventhierarchy, "select count('a') from DRYMARKETS where EVENTHIERARCHY = :EVENTHIERARCHY ");
    Sql.Set(Stm_Select_Count_Eventhierarchy, "EVENTHIERARCHY", Data.Eventhierarchy);
 
    Sql.Open_Cursor(Stm_Select_Count_Eventhierarchy);
    Sql.Fetch(Stm_Select_Count_Eventhierarchy, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Eventhierarchy, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Eventhierarchy);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Eventhierarchy;
---------------------------------------------
  procedure Delete_Eventhierarchy(Data  : in     Table_Drymarkets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Eventhierarchy, " delete from DRYMARKETS " & 
            "where EVENTHIERARCHY=:EVENTHIERARCHY"  ) ; 
      Sql.Set(Stm_Delete_Eventhierarchy, "EVENTHIERARCHY", Data.Eventhierarchy);
 
    Sql.Execute(Stm_Delete_Eventhierarchy);
  end Delete_Eventhierarchy;
---------------------------------------------


  -- Index 

  procedure Read_Marketname(Data  : in     Table_Drymarkets.Data_Type;
                       List  : in out Drymarkets_List_Pack.List_Type;
                       Order : in     Boolean := False;
                       Max   : in     Integer_4 := Integer_4'Last) is
    use Sql;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    if Order then
      Sql.Prepare(Stm_Select_Marketname_O, " select * from DRYMARKETS " & 
            "where MARKETNAME=:MARKETNAME" &
            " order by MARKETID "  ) ; 
      Sql.Set(Stm_Select_Marketname_O, "MARKETNAME", Data.Marketname);
 
      Read_List(Stm_Select_Marketname_O, List, Max);
    else
      Sql.Prepare(Stm_Select_Marketname, " select * from DRYMARKETS " & 
            "where MARKETNAME=:MARKETNAME"  ) ; 
      Sql.Set(Stm_Select_Marketname, "MARKETNAME", Data.Marketname);
 
      Read_List(Stm_Select_Marketname, List, Max);
    end if;
    if Start_Trans then Sql.Commit(Transaction); end if;
  end Read_Marketname;
---------------------------------------------
  procedure Read_One_Marketname(Data       : in out Table_Drymarkets.Data_Type;
                           Order      : in     Boolean := False;
                           End_Of_Set : in out Boolean) is
    List : Drymarkets_List_Pack.List_Type := Drymarkets_List_Pack.Create;
  begin
    Read_Marketname(Data, List, Order, 1);
    if Drymarkets_List_Pack.Is_Empty(List) then
      End_Of_Set := True;
    else
      End_Of_Set := False;
      Drymarkets_List_Pack.Remove_From_Head(List, Data);
    end if;
    Drymarkets_List_Pack.Release(List);
    end Read_One_Marketname;
---------------------------------------------

  function Count_Marketname(Data : Table_Drymarkets.Data_Type) return Integer_4 is
    use Sql;
    Count       : Integer_4 := 0;
    End_Of_Set  : Boolean := False;
    Start_Trans : constant Boolean := (Sql.Transaction_Status = Sql.None);
    Transaction : Sql.Transaction_Type;
  begin
    if Start_Trans then Sql.Start_Read_Write_Transaction(Transaction); end if;
    Sql.Prepare(Stm_Select_Count_Marketname, "select count('a') from DRYMARKETS where MARKETNAME = :MARKETNAME ");
    Sql.Set(Stm_Select_Count_Marketname, "MARKETNAME", Data.Marketname);
 
    Sql.Open_Cursor(Stm_Select_Count_Marketname);
    Sql.Fetch(Stm_Select_Count_Marketname, End_Of_Set);
    if not End_Of_Set then
      Sql.Get(Stm_Select_Count_Marketname, 1, Count);
    end if;
    Sql.Close_Cursor(Stm_Select_Count_Marketname);
    if Start_Trans then Sql.Commit(Transaction); end if;
    return Count;
  end Count_Marketname;
---------------------------------------------
  procedure Delete_Marketname(Data  : in     Table_Drymarkets.Data_Type) is
  begin
      Sql.Prepare(Stm_Delete_Marketname, " delete from DRYMARKETS " & 
            "where MARKETNAME=:MARKETNAME"  ) ; 
      Sql.Set(Stm_Delete_Marketname, "MARKETNAME", Data.Marketname);
 
    Sql.Execute(Stm_Delete_Marketname);
  end Delete_Marketname;
---------------------------------------------



  -- Procedures for all DBMS


  function Date_To_String(Date : in Sattmate_Calendar.Time_Type) return String is
    package Integer_2_Io is new Text_Io.Integer_Io(Integer_2);
    Date_String : String(1..10) := "yyyy-mm-dd";
  begin
    Integer_2_Io.Put(Date_String(9..10), Date.Day);
    Integer_2_Io.Put(Date_String(6..7), Date.Month);
    Integer_2_Io.Put(Date_String(1..4), Date.Year);
    if Date_String(9) = ' ' then Date_String(9) := '0'; end if;
    if Date_String(6) = ' ' then Date_String(6) := '0'; end if;
    return Date_String;
  end Date_To_String;
--------------------------------------------



  function To_String(Data : in Table_Drymarkets.Data_Type) return String is
  begin
    return
          " Marketid = " & Integer_4'Image(Data.Marketid) &
          " Bspmarket = " & Data.Bspmarket &
          " Markettype = " & Data.Markettype &
          " Eventhierarchy = " & General_Routines.Skip_Trailing_Blanks(Data.Eventhierarchy) &
          " Lastrefresh = " & Sattmate_Calendar.String_Date_And_Time(Data.Lastrefresh, Milliseconds => true) &
          " Turninginplay = " & Data.Turninginplay &
          " Menupath = " & General_Routines.Skip_Trailing_Blanks(Data.Menupath) &
          " Betdelay = " & Integer_4'Image(Data.Betdelay) &
          " Exchangeid = " & Integer_4'Image(Data.Exchangeid) &
          " Countrycode = " & General_Routines.Skip_Trailing_Blanks(Data.Countrycode) &
          " Marketname = " & General_Routines.Skip_Trailing_Blanks(Data.Marketname) &
          " Marketstatus = " & General_Routines.Skip_Trailing_Blanks(Data.Marketstatus) &
          " Eventdate = " & Sattmate_Calendar.String_Date_And_Time(Data.Eventdate, Milliseconds => true) &
          " Noofrunners = " & Integer_4'Image(Data.Noofrunners) &
          " Totalmatched = " & Integer_4'Image(Data.Totalmatched) &
          " Noofwinners = " & Integer_4'Image(Data.Noofwinners) &
          "";
  end To_String;
--------------------------------------------

end Table_Drymarkets ;

